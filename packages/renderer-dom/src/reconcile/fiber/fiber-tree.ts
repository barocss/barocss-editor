import { VNode, VNodeTag } from '../../vnode/types';
import { FiberNode } from './types';
import { getVNodeId } from '../utils/vnode-utils';
import { isAutoGeneratedSid } from '../../vnode/utils/sid-source';

/**
 * VNode를 깊은 복사 (재귀적으로 children도 복사)
 */
function deepCopyVNode(vnode: VNode): VNode {
  return {
    ...vnode,
    attrs: vnode.attrs ? { ...vnode.attrs } : undefined,
    style: vnode.style ? { ...vnode.style } : undefined,
    children: vnode.children ? vnode.children.map(child => {
      if (typeof child === 'object' && child !== null && 'tag' in child) {
        // VNode인 경우 재귀적으로 깊은 복사
        return deepCopyVNode(child);
      }
      // string/number인 경우 그대로 반환
      return child;
    }) : undefined,
    meta: vnode.meta ? { ...vnode.meta } : undefined,
    // props는 이미 외부에서 넘어온 것이므로 복사하지 않음
    // decorators는 VNodeBuilder에서 이미 처리되어 VNode 트리에 반영되므로 복사하지 않음
  };
}

/**
 * VNode 트리를 Fiber 트리로 변환
 * 
 * @param parent - 실제 DOM parent element
 * @param vnode - 현재 VNode
 * @param prevVNode - 이전 VNode (diffing용, deprecated - alternate 사용)
 * @param context - Reconciliation context
 * @param returnFiber - 작업 완료 후 돌아갈 Fiber (부모 Fiber)
 * @param index - children 배열에서의 인덱스
 * @param alternateFiber - React 방식: 이전 Fiber (alternate로 설정)
 * @returns 생성된 Fiber Node
 */
export function createFiberTree(
  parent: HTMLElement,
  vnode: VNode,
  prevVNode: VNode | undefined,
  context: any,
  returnFiber: FiberNode | null = null,
  index: number = 0,
  alternateFiber: FiberNode | null = null
): FiberNode {
  // React 방식: alternate에서 prevVNode 가져오기
  const actualPrevVNode = alternateFiber?.vnode || prevVNode;
  
  const fiber: FiberNode = {
    vnode,
    prevVNode: actualPrevVNode,
    domElement: null, // 나중에 reconcile 시점에 설정
    parent,
    parentFiber: returnFiber,
    child: null,
    sibling: null,
    return: returnFiber,
    effectTag: null,
    alternate: alternateFiber, // React 방식: 이전 Fiber 참조
    context,
    index
  };
  
  // IMPORTANT: vnode.text가 있고 children이 비어있으면 자식 Fiber를 생성하지 않음
  // vnode.text는 commitFiberNode에서 handleVNodeTextProperty로 처리됨
  if (vnode.text !== undefined && (!vnode.children || vnode.children.length === 0)) {
    // vnode.text만 있는 경우, 자식 Fiber 생성하지 않음
    return fiber;
  }
  
  // 자식 Fiber 생성 및 primitive text 정보 수집
  if (vnode.children && vnode.children.length > 0) {
    let prevSibling: FiberNode | null = null;
    let isFirstChild = true;
    const primitiveTextChildren: Array<{ text: string | number; index: number }> = [];
    
      // 이미 매칭된 prevChildVNode를 추적 (중복 매칭 방지)
    const matchedPrevChildVNodes = new Set<VNode>();
      // React 방식: 이미 매칭된 alternate Fiber를 추적 (중복 매칭 방지)
      const matchedAlternateFibers = new Set<FiberNode>();
    
    for (let i = 0; i < vnode.children.length; i++) {
      const child = vnode.children[i];
      
      // Primitive text (string/number)는 Fiber로 만들지 않음
      // 자식 Fiber 처리 후에 처리하기 위해 정보만 저장
      if (typeof child === 'string' || typeof child === 'number') {
        primitiveTextChildren.push({ text: child, index: i });
        continue;
      }
      
      // VNode만 Fiber로 변환
      if (typeof child === 'object' && child !== null) {
        const childVNode = child as VNode;
        
        // React 방식: alternate에서 이전 자식 Fiber 찾기
        let prevChildAlternate: FiberNode | null = null;
        const childId = getVNodeId(childVNode);
        // IMPORTANT: 자동 생성된 sid는 매칭에 사용하지 않음 (tag 기반 매칭 사용)
        const isChildIdAutoGenerated = childId ? isAutoGeneratedSid(childVNode) : false;
        const effectiveChildId = isChildIdAutoGenerated ? undefined : childId;
        
        // alternate의 자식들 중에서 매칭되는 Fiber 찾기
        if (fiber.alternate?.child) {
          let alternateChild = fiber.alternate.child;
          let childIndex = 0;
          
          // 1. sid/key로 먼저 찾기 (자동 생성된 sid 제외)
          if (effectiveChildId) {
            while (alternateChild) {
              // 이미 매칭된 alternate는 제외
              if (matchedAlternateFibers.has(alternateChild)) {
                alternateChild = alternateChild.sibling;
                continue;
              }
              const alternateId = getVNodeId(alternateChild.vnode);
              const isAlternateIdAutoGenerated = alternateId ? isAutoGeneratedSid(alternateChild.vnode) : false;
              const effectiveAlternateId = isAlternateIdAutoGenerated ? undefined : alternateId;
              if (effectiveAlternateId === effectiveChildId) {
                prevChildAlternate = alternateChild;
                break;
        }
              alternateChild = alternateChild.sibling;
            }
          }
          
          // 2. sid/key 매칭 실패 시 index로 찾기
          if (!prevChildAlternate) {
            alternateChild = fiber.alternate.child;
            childIndex = 0;
            while (alternateChild && childIndex < i) {
              alternateChild = alternateChild.sibling;
              childIndex++;
            }
            if (alternateChild && childIndex === i) {
              // 이미 매칭된 alternate는 제외
              if (!matchedAlternateFibers.has(alternateChild)) {
                // 같은 index의 Fiber가 있고, tag가 같으면 매칭
                const alternateTag = alternateChild.vnode.tag ?? (alternateChild.vnode.text !== undefined ? VNodeTag.TEXT : undefined);
              const childTag = childVNode.tag ?? (childVNode.text !== undefined ? VNodeTag.TEXT : undefined);
                if (alternateTag === childTag) {
                  prevChildAlternate = alternateChild;
              }
            }
          }
        }
          
          // 3. index 매칭도 실패 시 tag로만 매칭 (자동 생성된 sid가 있거나 ID가 없는 경우)
          // IMPORTANT: 순수하게 VNode 구조만 비교 (tag만 비교, class 등은 비교하지 않음)
          // 하지만 index를 고려하여 같은 index에 가까운 alternate를 우선 매칭
          if (!prevChildAlternate && (!effectiveChildId || isChildIdAutoGenerated) && childVNode.tag) {
            alternateChild = fiber.alternate.child;
            let bestMatch: FiberNode | null = null;
            let bestIndexDiff = Infinity;
            let alternateIndex = 0;
            
            while (alternateChild) {
              // 이미 매칭된 alternate는 제외
              if (matchedAlternateFibers.has(alternateChild)) {
                alternateChild = alternateChild.sibling;
                alternateIndex++;
                continue;
              }
              
              const alternateId = getVNodeId(alternateChild.vnode);
              const isAlternateIdAutoGenerated = alternateId ? isAutoGeneratedSid(alternateChild.vnode) : false;
              const alternateTag = alternateChild.vnode.tag;
              
              // 자동 생성된 sid가 있거나 ID가 없고 tag가 같으면 후보로 고려
              if ((!alternateId || isAlternateIdAutoGenerated) && alternateTag === childVNode.tag) {
                const indexDiff = Math.abs(alternateIndex - i);
                // 같은 index에 가까운 alternate를 우선 선택
                if (indexDiff < bestIndexDiff) {
                  bestIndexDiff = indexDiff;
                  bestMatch = alternateChild;
                }
              }
              
              alternateChild = alternateChild.sibling;
              alternateIndex++;
            }
            
            if (bestMatch) {
              prevChildAlternate = bestMatch;
            }
          }
        }
        
        // prevChildVNode는 alternate에서 가져오기 (하위 호환성)
        const prevChildVNode = prevChildAlternate?.vnode;
        
        
        // React 방식: 매칭된 alternate Fiber를 추적에 추가 (중복 매칭 방지)
        if (prevChildAlternate) {
          matchedAlternateFibers.add(prevChildAlternate);
        }
        
        // 매칭된 prevChildVNode를 추적에 추가
        if (prevChildVNode) {
          matchedPrevChildVNodes.add(prevChildVNode);
        }
        
        // IMPORTANT: nextVNode가 없으면 (childVNode가 null/undefined인 경우) 
        // prevChildVNode가 있으면 unmountComponent를 호출해야 하지만,
        // createFiberTree는 nextVNode가 있을 때만 호출되므로 여기서는 처리하지 않음
        // (removeStaleChildren에서 처리됨)
        
        // IMPORTANT: childVNode를 수정하기 전에 깊은 복사 (원본 VNode 보호)
        // childVNode는 참조로 전달되므로, 수정 시 원본이 변경될 수 있음
        // children 배열의 각 VNode 요소도 재귀적으로 깊은 복사 필요 (attrs가 손실되지 않도록)
        const childVNodeCopy: VNode = deepCopyVNode(childVNode);
        
        // IMPORTANT: prevChildVNode에서 ID를 childVNodeCopy로 전달 (ID가 없을 때)
        // 같은 컴포넌트를 항상 같은 ID로 추적하기 위해
        // Domain 지식 없이 getVNodeId()로 통일된 ID만 확인
        // childId는 위에서 이미 선언되었으므로 재사용
        const prevChildId = getVNodeId(prevChildVNode);
        if (!childId && prevChildId && prevChildVNode) {
          // prevChildVNode에 ID가 있고, 같은 구조적 타입(stype)이면 ID 복사
          // stype은 구조적 속성이므로 domain 지식이 아님
          if (prevChildVNode.stype && prevChildVNode.stype === childVNodeCopy.stype) {
            // prevChildVNode의 ID를 childVNodeCopy에 복사
            // sid는 top-level에 복사
            if (prevChildVNode.sid) {
              childVNodeCopy.sid = prevChildVNode.sid;
            } else if (prevChildVNode.attrs?.['data-decorator-sid']) {
              // decorator 정보는 attrs에 저장되므로 attrs에 복사
              if (!childVNodeCopy.attrs) childVNodeCopy.attrs = {};
              childVNodeCopy.attrs['data-decorator-sid'] = prevChildVNode.attrs['data-decorator-sid'];
            }
          }
        }
        
        // 실제 parent는 reconcile 시점에 결정되므로, 일단 현재 parent 사용
        // reconcile 시점에 올바른 parent로 업데이트됨
        // React 방식: prevChildAlternate를 alternate로 전달
        const childFiber = createFiberTree(
          parent, // 실제 parent는 reconcile 시점에 결정
          childVNodeCopy, // 복사본 사용
          prevChildVNode,
          context,
          fiber,
          i,
          prevChildAlternate // React 방식: 이전 자식 Fiber를 alternate로 전달
        );
        
        // 첫 번째 VNode child를 fiber.child로 설정
        if (isFirstChild) {
          fiber.child = childFiber;
          isFirstChild = false;
        } else if (prevSibling) {
          prevSibling.sibling = childFiber;
        }
        
        prevSibling = childFiber;
      }
    }
    
    // primitive text 정보 저장 (자식 Fiber 처리 후 처리하기 위해)
    if (primitiveTextChildren.length > 0) {
      fiber.primitiveTextChildren = primitiveTextChildren;
    }
  }
  
  return fiber;
}

