import { VNode, VNodeTag } from '../../vnode/types';
import { FiberNode } from './types';
import { getVNodeId } from '../utils/vnode-utils';
import { isAutoGeneratedSid } from '../../vnode/utils/sid-source';

/**
 * Deep copy VNode (recursively copy children as well)
 */
function deepCopyVNode(vnode: VNode): VNode {
  return {
    ...vnode,
    attrs: vnode.attrs ? { ...vnode.attrs } : undefined,
    style: vnode.style ? { ...vnode.style } : undefined,
    children: vnode.children ? vnode.children.map(child => {
      if (typeof child === 'object' && child !== null && 'tag' in child) {
        // If VNode, recursively deep copy
        return deepCopyVNode(child);
      }
      // If string/number, return as is
      return child;
    }) : undefined,
    meta: vnode.meta ? { ...vnode.meta } : undefined,
    // props are already from external, so don't copy
    // decorators are already processed in VNodeBuilder and reflected in VNode tree, so don't copy
  };
}

/**
 * Convert VNode tree to Fiber tree
 * 
 * @param parent - Actual DOM parent element
 * @param vnode - Current VNode
 * @param prevVNode - Previous VNode (for diffing, deprecated - use alternate)
 * @param context - Reconciliation context
 * @param returnFiber - Fiber to return to after work completes (parent Fiber)
 * @param index - Index in children array
 * @param alternateFiber - React-style: previous Fiber (set as alternate)
 * @returns Created Fiber Node
 */
export function createFiberTree(
  parent: HTMLElement,
  vnode: VNode,
  prevVNode: VNode | undefined,
  context: any,
  returnFiber: FiberNode | null = null,
  index: number = 0,
  alternateFiber: FiberNode | null = null
): FiberNode {
  // React-style: get prevVNode from alternate
  const actualPrevVNode = alternateFiber?.vnode || prevVNode;
  
  const fiber: FiberNode = {
    vnode,
    prevVNode: actualPrevVNode,
    domElement: null, // Set later at reconcile time
    parent,
    parentFiber: returnFiber,
    child: null,
    sibling: null,
    return: returnFiber,
    effectTag: null,
    alternate: alternateFiber, // React-style: reference to previous Fiber
    context,
    index
  };
  
  // IMPORTANT: if vnode.text exists and children is empty, don't create child Fibers
  // vnode.text is handled by handleVNodeTextProperty in commitFiberNode
  if (vnode.text !== undefined && (!vnode.children || vnode.children.length === 0)) {
    // If only vnode.text exists, don't create child Fibers
    return fiber;
  }
  
  // Create child Fibers and collect primitive text information
  if (vnode.children && vnode.children.length > 0) {
    let prevSibling: FiberNode | null = null;
    let isFirstChild = true;
    const primitiveTextChildren: Array<{ text: string | number; index: number }> = [];
    
      // Track already matched prevChildVNodes (prevent duplicate matching)
    const matchedPrevChildVNodes = new Set<VNode>();
      // React-style: track already matched alternate Fibers (prevent duplicate matching)
      const matchedAlternateFibers = new Set<FiberNode>();
    
    for (let i = 0; i < vnode.children.length; i++) {
      const child = vnode.children[i];
      
      // Don't create Fiber for primitive text (string/number)
      // Only store information to process after child Fiber processing
      if (typeof child === 'string' || typeof child === 'number') {
        primitiveTextChildren.push({ text: child, index: i });
        continue;
      }
      
      // Only convert VNode to Fiber
      if (typeof child === 'object' && child !== null) {
        const childVNode = child as VNode;
        
        // React-style: find previous child Fiber from alternate
        let prevChildAlternate: FiberNode | null = null;
        const childId = getVNodeId(childVNode);
        // IMPORTANT: don't use auto-generated sid for matching (use tag-based matching)
        const isChildIdAutoGenerated = childId ? isAutoGeneratedSid(childVNode) : false;
        const effectiveChildId = isChildIdAutoGenerated ? undefined : childId;
        
        // Find matching Fiber among alternate's children
        if (fiber.alternate?.child) {
          let alternateChild = fiber.alternate.child;
          let childIndex = 0;
          
          // 1. Find by sid/key first (exclude auto-generated sid)
          if (effectiveChildId) {
            while (alternateChild) {
              // Exclude already matched alternate
              if (matchedAlternateFibers.has(alternateChild)) {
                alternateChild = alternateChild.sibling;
                continue;
              }
              const alternateId = getVNodeId(alternateChild.vnode);
              const isAlternateIdAutoGenerated = alternateId ? isAutoGeneratedSid(alternateChild.vnode) : false;
              const effectiveAlternateId = isAlternateIdAutoGenerated ? undefined : alternateId;
              if (effectiveAlternateId === effectiveChildId) {
                prevChildAlternate = alternateChild;
                break;
        }
              alternateChild = alternateChild.sibling;
            }
          }
          
          // 2. If sid/key matching fails, find by index
          if (!prevChildAlternate) {
            alternateChild = fiber.alternate.child;
            childIndex = 0;
            while (alternateChild && childIndex < i) {
              alternateChild = alternateChild.sibling;
              childIndex++;
            }
            if (alternateChild && childIndex === i) {
              // Exclude already matched alternate
              if (!matchedAlternateFibers.has(alternateChild)) {
                // If Fiber at same index exists and tag matches, match
                const alternateTag = alternateChild.vnode.tag ?? (alternateChild.vnode.text !== undefined ? VNodeTag.TEXT : undefined);
              const childTag = childVNode.tag ?? (childVNode.text !== undefined ? VNodeTag.TEXT : undefined);
                if (alternateTag === childTag) {
                  prevChildAlternate = alternateChild;
              }
            }
          }
        }
          
          // 3. If index matching also fails, match by tag only (if auto-generated sid exists or no ID)
          // IMPORTANT: compare only VNode structure (compare only tag, not class, etc.)
          // However, prioritize alternate closest to same index
          if (!prevChildAlternate && (!effectiveChildId || isChildIdAutoGenerated) && childVNode.tag) {
            alternateChild = fiber.alternate.child;
            let bestMatch: FiberNode | null = null;
            let bestIndexDiff = Infinity;
            let alternateIndex = 0;
            
            while (alternateChild) {
              // Exclude already matched alternate
              if (matchedAlternateFibers.has(alternateChild)) {
                alternateChild = alternateChild.sibling;
                alternateIndex++;
                continue;
              }
              
              const alternateId = getVNodeId(alternateChild.vnode);
              const isAlternateIdAutoGenerated = alternateId ? isAutoGeneratedSid(alternateChild.vnode) : false;
              const alternateTag = alternateChild.vnode.tag;
              
              // Consider as candidate if auto-generated sid exists or no ID and tag matches
              if ((!alternateId || isAlternateIdAutoGenerated) && alternateTag === childVNode.tag) {
                const indexDiff = Math.abs(alternateIndex - i);
                // Prioritize alternate closest to same index
                if (indexDiff < bestIndexDiff) {
                  bestIndexDiff = indexDiff;
                  bestMatch = alternateChild;
                }
              }
              
              alternateChild = alternateChild.sibling;
              alternateIndex++;
            }
            
            if (bestMatch) {
              prevChildAlternate = bestMatch;
            }
          }
        }
        
        // Get prevChildVNode from alternate (for backward compatibility)
        const prevChildVNode = prevChildAlternate?.vnode;
        
        
        // React-style: add matched alternate Fiber to tracking (prevent duplicate matching)
        if (prevChildAlternate) {
          matchedAlternateFibers.add(prevChildAlternate);
        }
        
        // Add matched prevChildVNode to tracking
        if (prevChildVNode) {
          matchedPrevChildVNodes.add(prevChildVNode);
        }
        
        // IMPORTANT: if nextVNode is missing (childVNode is null/undefined)
        // and prevChildVNode exists, should call unmountComponent,
        // but createFiberTree is only called when nextVNode exists, so don't handle here
        // (handled in removeStaleChildren)
        
        // IMPORTANT: deep copy childVNode before modifying (protect original VNode)
        // childVNode is passed by reference, so original may be changed when modified
        // Each VNode element in children array also needs recursive deep copy (so attrs are not lost)
        const childVNodeCopy: VNode = deepCopyVNode(childVNode);
        
        // IMPORTANT: transfer ID from prevChildVNode to childVNodeCopy (when ID is missing)
        // To always track same component with same ID
        // Check only unified ID with getVNodeId() without domain knowledge
        // childId is already declared above, so reuse
        const prevChildId = getVNodeId(prevChildVNode);
        if (!childId && prevChildId && prevChildVNode) {
          // If prevChildVNode has ID and same structural type (stype), copy ID
          // stype is a structural property, not domain knowledge
          if (prevChildVNode.stype && prevChildVNode.stype === childVNodeCopy.stype) {
            // Copy prevChildVNode's ID to childVNodeCopy
            // Copy sid to top-level
            if (prevChildVNode.sid) {
              childVNodeCopy.sid = prevChildVNode.sid;
            } else if (prevChildVNode.attrs?.['data-decorator-sid']) {
              // Decorator info is stored in attrs, so copy to attrs
              if (!childVNodeCopy.attrs) childVNodeCopy.attrs = {};
              childVNodeCopy.attrs['data-decorator-sid'] = prevChildVNode.attrs['data-decorator-sid'];
            }
          }
        }
        
        // Actual parent is determined at reconcile time, so use current parent for now
        // Updated to correct parent at reconcile time
        // React-style: pass prevChildAlternate as alternate
        const childFiber = createFiberTree(
          parent, // Actual parent is determined at reconcile time
          childVNodeCopy, // Use copy
          prevChildVNode,
          context,
          fiber,
          i,
          prevChildAlternate // React-style: pass previous child Fiber as alternate
        );
        
        // Set first VNode child as fiber.child
        if (isFirstChild) {
          fiber.child = childFiber;
          isFirstChild = false;
        } else if (prevSibling) {
          prevSibling.sibling = childFiber;
        }
        
        prevSibling = childFiber;
      }
    }
    
    // Store primitive text info (to process after child Fiber processing)
    if (primitiveTextChildren.length > 0) {
      fiber.primitiveTextChildren = primitiveTextChildren;
    }
  }
  
  return fiber;
}

