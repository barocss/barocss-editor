/**
 * Fiber Reconciler Helper Functions
 * 
 * renderFiberNode와 commitFiberNode에서 사용되는 헬퍼 함수들을 분리
 * 각 함수는 단일 책임을 가지며 독립적으로 테스트 가능
 */

import { VNode } from '../../vnode/types';
import { FiberNode } from './types';
import { ComponentManager } from '../../component-manager';
import { getVNodeId, normalizeClasses } from '../utils/vnode-utils';
import { markAutoGeneratedSid, isAutoGeneratedSid } from '../../vnode/utils/sid-source';
import { findHostForChildVNode, findPrevChildVNode, findHostInParentChildren } from '../utils/host-finding';
import { createHostElement, updateHostElement, ComponentLifecycleManager } from '../utils/host-management';
import { DOMOperations } from '../../dom-operations';
import { cloneVNodeTree } from '../utils/vnode-clone';

/**
 * prevVNode에서 ID를 nextVNode로 전달
 * 같은 컴포넌트를 항상 같은 ID로 추적하기 위해
 */
export function transferVNodeIdFromPrev(
  vnode: VNode,
  prevVNode: VNode | undefined
): void {
  const vnodeId = getVNodeId(vnode);
  const prevVNodeId = getVNodeId(prevVNode);
  
  if (!vnodeId && prevVNodeId && prevVNode) {
    // prevVNode에 ID가 있고, 같은 구조적 타입(stype)이면 ID 복사
    // stype은 구조적 속성이므로 domain 지식이 아님
    if (prevVNode.stype && prevVNode.stype === vnode.stype) {
      // prevVNode의 ID를 vnode에 복사
      // sid는 top-level에 복사
      if (prevVNode.sid) {
        vnode.sid = prevVNode.sid;
      } else if (prevVNode.attrs?.['data-decorator-sid']) {
        // decorator 정보는 attrs에 저장되므로 attrs에 복사
        if (!vnode.attrs) vnode.attrs = {};
        vnode.attrs['data-decorator-sid'] = prevVNode.attrs['data-decorator-sid'];
      }
    }
  }
}

/**
 * 자동 생성 sid가 필요한 경우, stype과 index를 사용하여 일관된 ID 생성
 * 같은 stype과 index를 가진 컴포넌트는 같은 instance를 공유
 */
export function generateVNodeIdIfNeeded(
  vnode: VNode,
  fiber: FiberNode,
  components: ComponentManager
): void {
  // 이미 식별자가 있으면 아무것도 하지 않음
  if (getVNodeId(vnode)) {
    return;
  }

  // 컴포넌트(stype)인 경우 ComponentManager 기반으로 sid 생성
  if (vnode.stype && components) {
    const componentManager = components as any;
    if (typeof componentManager.generateComponentId === 'function') {
      const generatedSid = componentManager.generateComponentId(vnode, fiber.index);
      if (generatedSid) {
        markAutoGeneratedSid(vnode, generatedSid);
        return;
      }
    }
  }

  // 일반 Host VNode(Text 제외)는 tag + index 기반으로 안정적 ID 생성
  if (vnode.tag) {
    const parentId = getVNodeId(fiber.parentFiber?.vnode);
    const autoId = parentId
      ? `${parentId}:${String(vnode.tag)}-${fiber.index}`
      : `${String(vnode.tag)}-${fiber.index}`;
    markAutoGeneratedSid(vnode, autoId);
  }
}

/**
 * prevVNode.meta.domElement에서 host 찾기
 * ID 기반 매칭 또는 구조적 매칭 (태그 + 클래스)
 */
export function findHostFromPrevVNode(
  vnode: VNode,
  prevVNode: VNode | undefined
): HTMLElement | null {
  if (prevVNode?.meta?.domElement instanceof HTMLElement) {
    const vnodeId = getVNodeId(vnode);
    const prevVNodeId = getVNodeId(prevVNode);
    
    // 같은 ID를 가진 경우 재사용
    if (vnodeId && prevVNodeId && vnodeId === prevVNodeId) {
      return prevVNode.meta.domElement;
    }
    
    // ID가 없는 경우: 구조적 매칭 (태그 + 클래스)
    if (!vnodeId && !prevVNodeId && vnode.tag === prevVNode.tag) {
      const vnodeClasses = normalizeClasses(vnode.attrs?.class || vnode.attrs?.className).sort();
      const prevClasses = normalizeClasses(prevVNode.attrs?.class || prevVNode.attrs?.className).sort();
      if (vnodeClasses.length === prevClasses.length && 
          vnodeClasses.every((cls, i) => cls === prevClasses[i])) {
        return prevVNode.meta.domElement;
      }
    }
  }
  return null;
}

/**
 * prevVNode의 children에서 DOM 요소 참조 맵 구성
 */
export function buildPrevChildToElementMap(
  prevChildVNodes: (VNode | string | number)[]
): Map<VNode | string | number, HTMLElement | Text> {
  const prevChildToElement = new Map<VNode | string | number, HTMLElement | Text>();
  
  for (const prevChild of prevChildVNodes) {
    if (typeof prevChild === 'object' && prevChild?.meta?.domElement) {
      prevChildToElement.set(prevChild, prevChild.meta.domElement);
    }
  }
  
  return prevChildToElement;
}

/**
 * 기존 host 업데이트
 */
export function updateExistingHost(
  host: HTMLElement,
  parent: HTMLElement,
  vnode: VNode,
  prevVNode: VNode | undefined,
  index: number,
  prevChildVNodes: (VNode | string | number)[],
  deps: { dom: DOMOperations; components: ComponentManager; context?: any },
  context: any
): void {
  const { dom, components } = deps;
  let prevChildVNode = findPrevChildVNode(vnode, index, prevChildVNodes);
  // Domain 지식 없이 getVNodeId()로 ID 비교
  if (!prevChildVNode && prevVNode && getVNodeId(prevVNode) === getVNodeId(vnode)) {
    // prevVNode 자체가 현재 vnode와 매칭되는 경우 (root 레벨)
    prevChildVNode = prevVNode;
  }
  updateHostElement(
    host,
    parent,
    vnode,
    index,
    prevChildVNode,
    prevChildVNodes,
    dom,
    components as ComponentLifecycleManager,
    context
  );
}

/**
 * Host 찾기 또는 생성
 * 
 * IMPORTANT: findHostForChildVNode와 findHostInParentChildren은 인덱스 기반으로 매칭하므로,
 * 같은 ID를 가진 여러 VNode가 있어도 각각 올바른 DOM 요소를 찾습니다.
 * 따라서 usedDomElements는 필요 없습니다.
 */
export function findOrCreateHost(
  fiber: FiberNode,
  deps: { dom: DOMOperations; components: ComponentManager; context?: any },
  context: any
): HTMLElement {
  const { dom, components } = deps;
  const vnode = fiber.vnode;
  const prevVNode = fiber.prevVNode;
  const parent = fiber.parent;
  
  // 1. prevVNode.meta.domElement 확인
  let host = findHostFromPrevVNode(vnode, prevVNode);
  
  // 2. findHostForChildVNode로 찾기 (인덱스 기반 매칭)
  if (!host) {
    const prevChildVNodes = prevVNode?.children || [];
    const prevChildToElement = buildPrevChildToElementMap(prevChildVNodes);
    host = findHostForChildVNode(
      parent,
      vnode,
      fiber.index,
      prevChildVNodes,
      prevChildToElement
    );
  }
  
  // 3. findHostInParentChildren로 찾기 (인덱스 기반 매칭)
  if (!host) {
    host = findHostInParentChildren(parent, vnode, prevVNode, fiber.index);
  }
  
  // 4. 새로 생성
  // IMPORTANT: findHostForChildVNode와 findHostInParentChildren은 인덱스 기반으로 매칭하므로,
  // 같은 ID를 가진 여러 VNode가 있어도 각각 올바른 DOM 요소를 찾습니다.
  // 따라서 usedDomElements는 필요 없습니다.
  if (!host) {
    // createHostElement를 직접 사용 (중복 로직 제거)
    host = createHostElement(
      parent,
      vnode,
      fiber.index,
      dom,
      components as ComponentLifecycleManager,
      context
    );
  } else {
    // 기존 host 업데이트
    const prevChildVNodes = prevVNode?.children || [];
    updateExistingHost(
      host,
      parent,
      vnode,
      prevVNode,
      fiber.index,
      prevChildVNodes,
      deps,
      context
    );
  }
  
  return host;
}


/**
 * 직접 자식 Fiber들의 parent를 현재 host로 업데이트
 */
export function updateChildFiberParents(fiber: FiberNode, host: HTMLElement): void {
  let childFiber = fiber.child;
  while (childFiber) {
    childFiber.parent = host;
    childFiber = childFiber.sibling;
  }
}

/**
 * prevVNodeTree에 현재 VNode 스냅샷 저장
 */
export function saveVNodeToTree(
  vnode: VNode,
  prevVNodeTree: Map<string, VNode> | undefined
): void {
  // Domain 지식 없이 getVNodeId()로 ID 확인
  const vnodeId = getVNodeId(vnode);
  if (prevVNodeTree && vnodeId) {
    try {
      prevVNodeTree.set(vnodeId, cloneVNodeTree(vnode));
    } catch (error) {
      // Silent fail - prevVNodeTree 저장 실패는 치명적이지 않음
    }
  }
}

