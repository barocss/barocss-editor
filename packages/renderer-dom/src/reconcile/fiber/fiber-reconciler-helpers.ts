/**
 * Fiber Reconciler Helper Functions
 * 
 * renderFiberNode와 commitFiberNode에서 사용되는 헬퍼 함수들을 분리
 * 각 함수는 단일 책임을 가지며 독립적으로 테스트 가능
 */

import { VNode } from '../../vnode/types';
import { FiberNode } from './types';
import { ComponentManager } from '../../component-manager';
import { getVNodeId, normalizeClasses } from '../utils/vnode-utils';
import { markAutoGeneratedSid, isAutoGeneratedSid } from '../../vnode/utils/sid-source';
import { findHostForChildVNode, findPrevChildVNode, findHostInParentChildren } from '../utils/host-finding';
import { createHostElement, updateHostElement, ComponentLifecycleManager } from '../utils/host-management';
import { DOMOperations } from '../../dom-operations';
import { cloneVNodeTree } from '../utils/vnode-clone';

/**
 * prevVNode에서 ID를 nextVNode로 전달
 * 같은 컴포넌트를 항상 같은 ID로 추적하기 위해
 */
export function transferVNodeIdFromPrev(
  vnode: VNode,
  prevVNode: VNode | undefined
): void {
  const vnodeId = getVNodeId(vnode);
  const prevVNodeId = getVNodeId(prevVNode);
  
  if (!vnodeId && prevVNodeId && prevVNode) {
    // If prevVNode has ID and same structural type (stype), copy ID
    // stype is a structural property, not domain knowledge
    if (prevVNode.stype && prevVNode.stype === vnode.stype) {
      // Copy prevVNode's ID to vnode
      // Copy sid to top-level
      if (prevVNode.sid) {
        vnode.sid = prevVNode.sid;
      } else if (prevVNode.attrs?.['data-decorator-sid']) {
        // Decorator info is stored in attrs, so copy to attrs
        if (!vnode.attrs) vnode.attrs = {};
        vnode.attrs['data-decorator-sid'] = prevVNode.attrs['data-decorator-sid'];
      }
    }
  }
}

/**
 * Generate consistent ID using stype and index when auto-generated sid is needed
 * Components with same stype and index share the same instance
 */
export function generateVNodeIdIfNeeded(
  vnode: VNode,
  fiber: FiberNode,
  components: ComponentManager
): void {
  // Do nothing if identifier already exists
  if (getVNodeId(vnode)) {
    return;
  }

  // If component (stype), generate sid based on ComponentManager
  if (vnode.stype && components) {
    const componentManager = components as any;
    if (typeof componentManager.generateComponentId === 'function') {
      const generatedSid = componentManager.generateComponentId(vnode, fiber.index);
      if (generatedSid) {
        markAutoGeneratedSid(vnode, generatedSid);
        return;
      }
    }
  }

  // Regular Host VNode (excluding Text) generate stable ID based on tag + index
  if (vnode.tag) {
    const parentId = getVNodeId(fiber.parentFiber?.vnode);
    const autoId = parentId
      ? `${parentId}:${String(vnode.tag)}-${fiber.index}`
      : `${String(vnode.tag)}-${fiber.index}`;
    markAutoGeneratedSid(vnode, autoId);
  }
}

/**
 * Find host from prevVNode.meta.domElement
 * ID-based matching or structural matching (tag + class)
 */
export function findHostFromPrevVNode(
  vnode: VNode,
  prevVNode: VNode | undefined
): HTMLElement | null {
  if (prevVNode?.meta?.domElement instanceof HTMLElement) {
    const vnodeId = getVNodeId(vnode);
    const prevVNodeId = getVNodeId(prevVNode);
    
    // Reuse if same ID
    if (vnodeId && prevVNodeId && vnodeId === prevVNodeId) {
      return prevVNode.meta.domElement;
    }
    
    // If no ID: structural matching (tag + class)
    if (!vnodeId && !prevVNodeId && vnode.tag === prevVNode.tag) {
      const vnodeClasses = normalizeClasses(vnode.attrs?.class || vnode.attrs?.className).sort();
      const prevClasses = normalizeClasses(prevVNode.attrs?.class || prevVNode.attrs?.className).sort();
      if (vnodeClasses.length === prevClasses.length && 
          vnodeClasses.every((cls, i) => cls === prevClasses[i])) {
        return prevVNode.meta.domElement;
      }
    }
  }
  return null;
}

/**
 * prevVNode의 children에서 DOM 요소 참조 맵 구성
 */
export function buildPrevChildToElementMap(
  prevChildVNodes: (VNode | string | number)[]
): Map<VNode | string | number, HTMLElement | Text> {
  const prevChildToElement = new Map<VNode | string | number, HTMLElement | Text>();
  
  for (const prevChild of prevChildVNodes) {
    if (typeof prevChild === 'object' && prevChild?.meta?.domElement) {
      prevChildToElement.set(prevChild, prevChild.meta.domElement);
    }
  }
  
  return prevChildToElement;
}

/**
 * 기존 host 업데이트
 */
export function updateExistingHost(
  host: HTMLElement,
  parent: HTMLElement,
  vnode: VNode,
  prevVNode: VNode | undefined,
  index: number,
  prevChildVNodes: (VNode | string | number)[],
  deps: { dom: DOMOperations; components: ComponentManager; context?: any },
  context: any
): void {
  const { dom, components } = deps;
  let prevChildVNode = findPrevChildVNode(vnode, index, prevChildVNodes);
  // Compare IDs with getVNodeId() without domain knowledge
  if (!prevChildVNode && prevVNode && getVNodeId(prevVNode) === getVNodeId(vnode)) {
    // When prevVNode itself matches current vnode (root level)
    prevChildVNode = prevVNode;
  }
  updateHostElement(
    host,
    parent,
    vnode,
    index,
    prevChildVNode,
    prevChildVNodes,
    dom,
    components as ComponentLifecycleManager,
    context
  );
}

/**
 * Find or create host
 * 
 * IMPORTANT: findHostForChildVNode and findHostInParentChildren match based on index,
 * so even if multiple VNodes have the same ID, each finds the correct DOM element.
 * Therefore, usedDomElements is not needed.
 */
export function findOrCreateHost(
  fiber: FiberNode,
  deps: { dom: DOMOperations; components: ComponentManager; context?: any },
  context: any
): HTMLElement {
  const { dom, components } = deps;
  const vnode = fiber.vnode;
  const prevVNode = fiber.prevVNode;
  const parent = fiber.parent;
  
  // 1. Check prevVNode.meta.domElement
  let host = findHostFromPrevVNode(vnode, prevVNode);
  
  // 2. Find with findHostForChildVNode (index-based matching)
  if (!host) {
    const prevChildVNodes = prevVNode?.children || [];
    const prevChildToElement = buildPrevChildToElementMap(prevChildVNodes);
    host = findHostForChildVNode(
      parent,
      vnode,
      fiber.index,
      prevChildVNodes,
      prevChildToElement
    );
  }
  
  // 3. Find with findHostInParentChildren (index-based matching)
  if (!host) {
    host = findHostInParentChildren(parent, vnode, prevVNode, fiber.index);
  }
  
  // 4. Create new
  // IMPORTANT: findHostForChildVNode and findHostInParentChildren match based on index,
  // so even if multiple VNodes have the same ID, each finds the correct DOM element.
  // Therefore, usedDomElements is not needed.
  if (!host) {
    // Use createHostElement directly (remove duplicate logic)
    host = createHostElement(
      parent,
      vnode,
      fiber.index,
      dom,
      components as ComponentLifecycleManager,
      context
    );
  } else {
    // Update existing host
    const prevChildVNodes = prevVNode?.children || [];
    updateExistingHost(
      host,
      parent,
      vnode,
      prevVNode,
      fiber.index,
      prevChildVNodes,
      deps,
      context
    );
  }
  
  return host;
}


/**
 * 직접 자식 Fiber들의 parent를 현재 host로 업데이트
 */
export function updateChildFiberParents(fiber: FiberNode, host: HTMLElement): void {
  let childFiber = fiber.child;
  while (childFiber) {
    childFiber.parent = host;
    childFiber = childFiber.sibling;
  }
}

/**
 * prevVNodeTree에 현재 VNode 스냅샷 저장
 */
export function saveVNodeToTree(
  vnode: VNode,
  prevVNodeTree: Map<string, VNode> | undefined
): void {
  // Check ID using getVNodeId() without domain knowledge
  const vnodeId = getVNodeId(vnode);
  if (prevVNodeTree && vnodeId) {
    try {
      prevVNodeTree.set(vnodeId, cloneVNodeTree(vnode));
    } catch (error) {
      // Silent fail - prevVNodeTree save failure is not critical
    }
  }
}

