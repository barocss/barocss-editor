import { VNode } from '../../vnode/types';
import { FiberNode } from './types';
import { createFiberTree } from './fiber-tree';
import { FiberScheduler, FiberReconcileFunction } from './fiber-scheduler';
import { FiberPriority } from './types';
import { DOMOperations } from '../../dom-operations';
import { ComponentManager } from '../../component-manager';
import { handlePortalVNode } from '../utils/portal-handler';
import { handleVNodeTextProperty, handlePrimitiveTextChild } from '../utils/text-node-handlers';
import { getVNodeId } from '../utils/vnode-utils';
import {
  transferVNodeIdFromPrev,
  generateVNodeIdIfNeeded,
  findOrCreateHost,
  updateChildFiberParents
} from './fiber-reconciler-helpers';
import { getHostSibling } from './get-host-sibling';
import { isAutoGeneratedSid } from '../../vnode/utils/sid-source';
import { logger, LogCategory } from '../../utils/logger';
import { EffectTag } from './types';
import { VNodeTag, DOMAttribute } from '../../vnode/types';

/**
 * Fiber reconcile에 필요한 의존성
 */
export interface FiberReconcileDependencies {
  dom: DOMOperations;
  components: ComponentManager;
  currentVisitedPortalIds: Set<string> | null;
  portalHostsById: Map<string, { target: HTMLElement, host: HTMLElement }>;
  // Root 레벨 처리를 위한 추가 정보
  rootModel?: any; // model.text 처리를 위한 model 참조
  rootSid?: string; // rootVNode의 sid
  context?: any; // Reconciliation context (for unmountComponent)
  prevRootFiber?: FiberNode | null; // React 방식: 이전 Fiber tree (alternate로 사용)
}

/**
 * 얕은 비교를 통한 Props 변경 확인
 */
function arePropsEqual(prev: any, next: any): boolean {
  if (prev === next) return true;
  if (!prev || !next) return false;
  
  const prevKeys = Object.keys(prev);
  const nextKeys = Object.keys(next);
  
  if (prevKeys.length !== nextKeys.length) return false;
  
  for (const key of nextKeys) {
    if (prev[key] !== next[key]) return false;
  }
  
  return true;
}

/**
 * Fiber 기반 reconcile
 * 
 * VNode 트리를 Fiber 트리로 변환하고, 각 Fiber 노드를 개별적으로 처리
 * 
 * @param container - Root container element
 * @param vnode - VNode tree to reconcile
 * @param prevVNode - Previous VNode (for diffing)
 * @param context - Reconciliation context
 * @param deps - Fiber reconcile에 필요한 의존성
 * @param onComplete - Fiber 작업 완료 시 호출될 콜백 (optional)
 */
export function reconcileWithFiber(
  container: HTMLElement,
  vnode: VNode,
  prevVNode: VNode | undefined,
  context: any,
  deps: FiberReconcileDependencies,
  onComplete?: (rootFiber: FiberNode) => void
): void {
  // React 방식: 이전 rootFiber를 alternate로 설정
  const prevRootFiber = deps.prevRootFiber || null;
  
  // 1. Fiber 트리 생성 (이전 rootFiber를 alternate로 전달)
  const rootFiber = createFiberTree(container, vnode, prevVNode, context, null, 0, prevRootFiber);
  
  // 2. Fiber render 함수 정의 (Render Phase)
  // 각 Fiber 노드에 대해 변경사항 계산만 수행 (DOM 조작 없음)
  const fiberRender: FiberReconcileFunction = (fiber: FiberNode) => {
    renderFiberNode(fiber, deps, context);
    delete (fiber as any).__isReturningToParent;
  };
  
  // 3. Custom FiberScheduler that sets __isReturningToParent flag when returning to parent
  class CustomFiberScheduler extends FiberScheduler {
    protected performUnitOfWork(fiber: FiberNode): FiberNode | null {
      // 1. 현재 Fiber render (Render Phase)
      this.reconcileFiber(fiber);
      
      // 2. 자식이 있으면 자식 반환 (다음 작업)
      if (fiber.child) {
        return fiber.child;
      }
      
      // 3. 형제가 있으면 형제 반환
      if (fiber.sibling) {
        return fiber.sibling;
      }
      
      // 4. 부모로 돌아가서 형제 찾기
      // IMPORTANT: 부모로 돌아갈 때, 부모의 모든 자식이 처리되었으므로
      // 부모의 후처리(primitive text, stale decorator 제거)를 수행해야 함
      let nextFiber = fiber.return;
      while (nextFiber) {
        // 부모로 돌아갈 때, 부모의 자식이 모두 처리되었으므로
        // 부모에 대해 fiberReconcile을 다시 호출하여 후처리 수행
        // __isReturningToParent 플래그를 설정하여 후처리 수행
        (nextFiber as any).__isReturningToParent = true;
        this.reconcileFiber(nextFiber);
        
        if (nextFiber.sibling) {
          return nextFiber.sibling;
        }
        nextFiber = nextFiber.return;
      }
      
      return null; // 완료
    }
  }
  
  // 4. Fiber Scheduler로 작업 시작 (비동기 yield)
  const scheduler = new CustomFiberScheduler(fiberRender, () => {
    // Render Phase 완료 후 Commit Phase 실행
    commitFiberTree(rootFiber, deps, context);
    if (onComplete) {
      onComplete(rootFiber);
    }
  });
  scheduler.scheduleWork(rootFiber, FiberPriority.Normal);
}

/**
 * 단일 Fiber 노드를 render (Render Phase)
 * DOM 조작 없이 변경사항만 계산하고 effectTag 설정
 * 
 * @param fiber - 처리할 Fiber 노드
 * @param deps - 필요한 의존성
 * @param context - Reconciliation context
 */
export function renderFiberNode(
  fiber: FiberNode,
  deps: FiberReconcileDependencies,
  context: any
): void {
  const { dom, components, currentVisitedPortalIds, portalHostsById } = deps;
  
  // Primitive text는 Fiber로 변환하지 않으므로 여기서는 VNode만 처리
  const vnode = fiber.vnode;
  // React 방식: alternate에서 prevVNode 가져오기 (fiber.prevVNode는 deprecated)
  const prevVNode = fiber.alternate?.vnode || fiber.prevVNode;
  const parent = fiber.parent;
  
  // IMPORTANT: prevVNode에서 ID를 nextVNode로 전달 (ID가 없을 때)
  transferVNodeIdFromPrev(vnode, prevVNode);
  
  // IMPORTANT: 자동 생성 sid가 필요한 경우, stype과 index를 사용하여 일관된 ID 생성
  generateVNodeIdIfNeeded(vnode, fiber, deps.components);
  
  // 1. Portal 처리
  if (handlePortalVNode(
    vnode,
    dom,
    (host, prev, next, ctx) => {
      // Portal 내부 reconcile은 별도 처리
      // Fiber 구조를 따르지 않고 직접 reconcile
      const portalFiber = createFiberTree(host, next, prev, ctx);
      const portalScheduler = new FiberScheduler((f: FiberNode) => {
        renderFiberNode(f, deps, ctx);
      }, () => {
        // Portal도 commit phase 실행
        commitFiberTree(portalFiber, deps, ctx);
      });
      portalScheduler.scheduleWork(portalFiber, FiberPriority.Normal);
    },
    currentVisitedPortalIds,
    portalHostsById
  )) {
    // Portal은 처리되었으므로 여기서 종료
    return;
  }
  
  // 2. nextVNode가 없으면 prevVNode가 있으면 unmountComponent 호출
  if (!vnode || typeof vnode !== 'object') {
    // prevVNode가 있고 stype이 있으면 unmountComponent 호출
    if (prevVNode && prevVNode.stype && prevVNode.sid) {
      const prevHost = prevVNode.meta?.domElement;
      if (prevHost && prevHost instanceof HTMLElement) {
        try {
          components.unmountComponent(prevVNode, context);
        } catch (err) {
          logger.error(LogCategory.FIBER, 'Error unmounting component in renderFiberNode', err);
        }
      }
    }
    return;
  }
  
  // tag가 없고 text도 없지만 children이 있으면, children을 직접 parent에 추가
  // (루트 VNode로 감싼 경우 등)
  if (!vnode.tag && vnode.children && vnode.children.length > 0) {
    // children은 Fiber scheduler가 자동으로 처리함
    // 여기서는 DOM 요소 참조만 설정 (parent를 사용)
      if (!vnode.meta) {
        vnode.meta = {};
      }
    vnode.meta.domElement = parent;
    fiber.domElement = parent;
    
    // 4-1. 직접 자식 Fiber들의 parent를 현재 parent로 업데이트
    updateChildFiberParents(fiber, parent);
    
    // children 처리는 Fiber scheduler가 자동으로 수행
    return;
    }
  
  // tag가 없고 text도 없고 children도 없으면 처리할 것이 없음
  if (!vnode.tag && !vnode.text) {
    return;
  }
  
  if (vnode.text !== undefined && (!vnode.children || vnode.children.length === 0)) {
    logger.debug(LogCategory.FIBER, 'text vnode detected', {
      sid: vnode.sid,
      tag: vnode.tag,
      text: vnode.text,
      parentTag: parent?.nodeType === 1 ? (parent as HTMLElement).tagName : parent?.nodeName
    });
  }
  
  // 3. 타입 비교 (reconcile 규칙: 타입이 다르면 재사용 불가)
  const isTextVNode = (node: VNode) => node.tag === VNodeTag.TEXT || (!node.tag && node.text !== undefined);
  const isHostVNode = (node: VNode) => node.tag && node.tag !== VNodeTag.TEXT;
  
  const prevType = prevVNode 
    ? (isTextVNode(prevVNode) ? 'text' : isHostVNode(prevVNode) ? 'host' : 'unknown')
    : null;
  const nextType = isTextVNode(vnode) ? 'text' : isHostVNode(vnode) ? 'host' : 'unknown';
  const typeChanged = prevType !== null && prevType !== nextType;
  
  
  // 4. effectTag 결정 (DOM 조작 없이 계산만)
  // prevVNode가 없으면 PLACEMENT, 타입이 바뀌면 PLACEMENT (기존 DOM 제거 후 새로 생성), 있으면 UPDATE
  if (!prevVNode || typeChanged) {
    fiber.effectTag = EffectTag.PLACEMENT;
  } else {
    fiber.effectTag = EffectTag.UPDATE;
  }
  
  // 5. DOM 요소 생성 또는 찾기 (React 방식: Render Phase에서 DOM 생성)
  // Render Phase에서는 DOM을 생성하되 삽입은 하지 않음
  // IMPORTANT: 타입이 바뀌면 기존 DOM을 재사용하지 않고 새로 생성
  let domElement: HTMLElement | Text | null = null;
  
  // 기존 DOM 요소 찾기 (prevVNode에서, 타입이 같을 때만 재사용)
  if (prevVNode?.meta?.domElement && !typeChanged) {
    domElement = prevVNode.meta.domElement as HTMLElement | Text;
  } else {
    // 새 DOM 요소 생성 (삽입은 commit phase에서 수행)
    if (vnode.tag === VNodeTag.TEXT || (!vnode.tag && vnode.text !== undefined)) {
      // Text node 생성
      const doc = parent.ownerDocument || document;
      const expectedText = String(vnode.text);
      domElement = doc.createTextNode(expectedText);
    } else if (vnode.tag) {
      // Host element 생성 (삽입은 하지 않음)
      const { dom } = deps;
      domElement = dom.createSimpleElement(String(vnode.tag));
      
      // VNode identifier attributes 설정
      if (vnode.sid && !isAutoGeneratedSid(vnode)) {
        dom.setAttribute(domElement, DOMAttribute.BC_SID, String(vnode.sid));
      }
      
      // attrs 설정 (decorator 정보 등)
      if (vnode.attrs) {
        for (const [key, value] of Object.entries(vnode.attrs)) {
          if (value !== undefined && value !== null) {
            dom.setAttribute(domElement, key, String(value));
          }
        }
      }
    }
  }
  
  // DOM 요소 참조 저장
  if (!vnode.meta) {
    vnode.meta = {};
  }
  vnode.meta.domElement = domElement;
  fiber.domElement = domElement;
  
  // 7. Primitive text children 처리는 자식 Fiber 처리 후에 수행됨
  // (performUnitOfWork에서 자식이 없을 때 처리)
  
  // 8. 자식 Fiber 노드들은 FiberScheduler가 자동으로 처리
  // performUnitOfWork에서 fiber.child를 반환하여 다음 작업으로 설정됨

  // React 방식: prevVNodeTree 대신 Fiber tree의 alternate로 이전 상태 유지
  // 별도 저장 불필요
}

/**
 * Fiber 트리를 commit (Commit Phase)
 * 모든 Fiber 노드를 순회하면서 effectTag에 따라 DOM 조작 수행
 * 
 * @param rootFiber - 루트 Fiber 노드
 * @param deps - 필요한 의존성
 * @param context - Reconciliation context
 */
export function commitFiberTree(
  rootFiber: FiberNode,
  deps: FiberReconcileDependencies,
  context: any
): void {
  // Fiber 트리를 순회하면서 commit 수행
  let currentFiber: FiberNode | null = rootFiber;
  
  while (currentFiber) {
    // 현재 Fiber commit
    commitFiberNode(currentFiber, deps, context);
    
    // 자식이 있으면 자식으로 이동
    if (currentFiber.child) {
      currentFiber = currentFiber.child;
      continue;
    }
    
    // 자식이 없으면 (자식이 모두 commit된 상태) 후처리 수행
    // Primitive text 처리 및 stale children 제거
    if (currentFiber.primitiveTextChildren && currentFiber.primitiveTextChildren.length > 0) {
      processPrimitiveTextChildren(currentFiber, deps);
    }
    removeStaleChildren(currentFiber, deps);
    
    // 형제가 있으면 형제로 이동
    if (currentFiber.sibling) {
      currentFiber = currentFiber.sibling;
      continue;
    }
    
    // 부모로 돌아가서 형제 찾기
    // 부모로 돌아갈 때도 부모의 후처리 수행 (자식이 모두 commit된 상태)
    let parentFiber = currentFiber.return;
    while (parentFiber && !parentFiber.sibling) {
      // 부모의 후처리 수행
      if (parentFiber.primitiveTextChildren && parentFiber.primitiveTextChildren.length > 0) {
        processPrimitiveTextChildren(parentFiber, deps);
      }
      removeStaleChildren(parentFiber, deps);
      
      parentFiber = parentFiber.return;
    }
    if (parentFiber) {
      // 부모의 후처리 수행
      if (parentFiber.primitiveTextChildren && parentFiber.primitiveTextChildren.length > 0) {
        processPrimitiveTextChildren(parentFiber, deps);
      }
      removeStaleChildren(parentFiber, deps);
      
      currentFiber = parentFiber.sibling;
    } else {
      currentFiber = null;
    }
  }
}

/**
 * 단일 Fiber 노드를 commit (Commit Phase)
 * effectTag에 따라 DOM 조작 수행
 * 
 * @param fiber - 처리할 Fiber 노드
 * @param deps - 필요한 의존성
 * @param context - Reconciliation context
 */
export function commitFiberNode(
  fiber: FiberNode,
  deps: FiberReconcileDependencies,
  context: any
): void {
  const { dom, components } = deps;
  const vnode = fiber.vnode;
  // React 방식: alternate에서 prevVNode 가져오기 (fiber.prevVNode는 deprecated)
  const prevVNode = fiber.alternate?.vnode || fiber.prevVNode;
  const parent = fiber.parent;
  
  // effectTag가 없으면 처리하지 않음
  if (!fiber.effectTag) {
    return;
  }
  
  // Portal은 별도 처리 (이미 render phase에서 처리됨)
  // TODO: Portal도 commit phase로 이동 필요
  
  // vnode가 없으면 DELETION 처리
  if (!vnode || typeof vnode !== 'object') {
    if (fiber.effectTag === EffectTag.DELETION && prevVNode) {
      const prevHost = prevVNode.meta?.domElement;
      if (prevHost && prevHost instanceof HTMLElement) {
        try {
          components.unmountComponent(prevVNode, context);
        } catch (err) {
          logger.error(LogCategory.FIBER, 'Error unmounting component in commitFiberNode', err);
        }
        if (prevHost.parentNode) {
          prevHost.parentNode.removeChild(prevHost);
        }
      }
    }
    return;
  }
  
  // tag가 없고 text도 없지만 children이 있으면, children을 직접 parent에 추가
  if (!vnode.tag && vnode.children && vnode.children.length > 0) {
    if (!vnode.meta) {
      vnode.meta = {};
    }
    vnode.meta.domElement = parent;
    fiber.domElement = parent;
    updateChildFiberParents(fiber, parent);
    return;
  }
  
  // tag가 없고 text도 없고 children도 없으면 처리할 것이 없음
  if (!vnode.tag && !vnode.text) {
    return;
  }
  
  // React 방식: Commit Phase에서는 DOM 삽입만 수행
  // DOM 요소는 Render Phase에서 이미 생성되었으므로, 여기서는 삽입만 수행
  const domElement = fiber.domElement;
  
  if (!domElement) {
    // domElement가 없으면 에러 (Render Phase에서 생성되어야 함)
    logger.error(LogCategory.FIBER, 'domElement is not set. Render Phase should create it.');
    return;
  }
  
  // 타입 비교 (reconcile 규칙: 타입이 바뀌면 기존 DOM 제거 후 새로 삽입)
  const isTextVNode = (node: VNode) => node.tag === VNodeTag.TEXT || (!node.tag && node.text !== undefined);
  const isHostVNode = (node: VNode) => node.tag && node.tag !== VNodeTag.TEXT;
  
  const prevType = prevVNode 
    ? (isTextVNode(prevVNode) ? 'text' : isHostVNode(prevVNode) ? 'host' : 'unknown')
    : null;
  const nextType = isTextVNode(vnode) ? 'text' : isHostVNode(vnode) ? 'host' : 'unknown';
  const typeChanged = prevType !== null && prevType !== nextType;
  
  // 타입이 바뀐 경우: 기존 DOM 제거
  if (typeChanged && prevVNode?.meta?.domElement) {
    const prevDomElement = prevVNode.meta.domElement;
    if (prevDomElement.parentNode) {
      prevDomElement.parentNode.removeChild(prevDomElement);
    }
    // Component unmount (HTMLElement인 경우만)
    if (prevDomElement instanceof HTMLElement && prevVNode.stype && prevVNode.sid) {
      try {
        components.unmountComponent(prevVNode, context);
      } catch (err) {
        console.error('[Fiber.commitFiberNode] Error unmounting component:', err);
      }
    }
  }
  
  // React의 commitPlacement: DOM 삽입만 수행
  if (fiber.effectTag === EffectTag.PLACEMENT) {
    let actualParent: HTMLElement | null = null;
    let parentCandidate = fiber.parentFiber;
    while (parentCandidate && !actualParent) {
      if (parentCandidate.domElement instanceof HTMLElement) {
        actualParent = parentCandidate.domElement;
        break;
      }
      parentCandidate = parentCandidate.parentFiber;
    }
    if (!actualParent && parent instanceof HTMLElement) {
      actualParent = parent;
    }
    
    // React의 getHostSibling: 다음 형제의 DOM 노드 찾기
    let before = getHostSibling(fiber);
    
    if (!actualParent) {
      logger.error(LogCategory.FIBER, 'actualParent is not available for placement', {
        fiberVNode: {
          sid: vnode.sid,
          tag: vnode.tag,
          text: vnode.text
        },
        parentFiberVNode: fiber.parentFiber?.vnode,
        parentNodeType: parent?.nodeType,
        parentNodeValue: (parent as any)?.nodeValue
      });
      return;
    }
    
    // before 노드가 actualParent의 자식인지 확인
    // React는 commit phase에서 다음 형제가 아직 commit되지 않았을 수 있으므로,
    // before 노드가 actualParent의 자식이 아닐 수 있음
    // 이 경우 before를 null로 설정하여 appendChild와 동일하게 처리
    if (before && before.parentNode !== actualParent) {
      before = null;
    }
    
    // DOM 삽입 (React의 commitPlacement와 동일)
    if (!(actualParent instanceof HTMLElement)) {
      logger.error(LogCategory.FIBER, 'actualParent is not HTMLElement', {
        fiberVNode: {
          sid: vnode.sid,
          tag: vnode.tag,
          text: vnode.text
        },
        parentFiberVNode: {
          sid: fiber.parentFiber?.vnode?.sid,
          tag: fiber.parentFiber?.vnode?.tag,
          text: fiber.parentFiber?.vnode?.text
        },
        parentNodeType: actualParent?.nodeType,
        parentNodeValue: (actualParent as any)?.nodeValue
      });
    }


    if (domElement.parentNode !== actualParent) {
      // DOM 요소가 부모에 없으면 삽입
      actualParent.insertBefore(domElement, before);
    } else if (domElement.nextSibling !== before && before !== domElement) {
      // DOM 요소가 부모에 있지만 잘못된 위치에 있으면 이동
      actualParent.insertBefore(domElement, before);
    }
    
    // Component lifecycle: mount when component VNode has stype
    // IMPORTANT: 이미 마운트된 컴포넌트는 mountComponent를 호출하지 않음
    if (domElement instanceof HTMLElement && vnode.stype) {
      const componentManager = components as any;
      let shouldMount = false;
      
      if (vnode.sid) {
        // 이미 마운트된 컴포넌트인지 확인 (sid로 확인)
          const existingInstance = componentManager.getComponentInstance(vnode.sid);
          // existingInstance가 없거나 mounted가 false이거나 element가 다르면 마운트 필요
          if (!existingInstance || !existingInstance.mounted || existingInstance.element !== domElement) {
            shouldMount = true;
          }
      } else {
        // sid가 없는 경우: generateComponentId로 확인
        const componentId = componentManager.generateComponentId(vnode, fiber.index);
        if (componentId && typeof componentManager.getComponentInstance === 'function') {
          const existingInstance = componentManager.getComponentInstance(componentId);
          if (!existingInstance || !existingInstance.mounted || existingInstance.element !== domElement) {
            shouldMount = true;
          }
        } else {
          shouldMount = true;
        }
      }
      
      if (shouldMount) {
        try {
          components.mountComponent(vnode, domElement, context || ({} as any));
        } catch (err) {
          logger.error(LogCategory.FIBER, 'Error mounting component', err);
        }
      }
    }
  }
  
  // DOM 요소 참조 저장 (이미 Render Phase에서 설정되었지만, 확실히 하기 위해)
  if (!vnode.meta) {
    vnode.meta = {};
  }
  vnode.meta.domElement = domElement;
  
  // Text 노드 업데이트 (Text VNode)
  // reconcile 규칙: prevVNode와 nextVNode를 비교하여 업데이트
  if (domElement instanceof Text) {
    const nextText = vnode.text !== undefined ? String(vnode.text) : '';
    const currentText = domElement.textContent || ''; // 실제 DOM의 현재 텍스트
    
    // 타입이 바뀌지 않았고 텍스트가 다르면 업데이트
    if (!typeChanged && currentText !== nextText) {
      logger.debug(LogCategory.FIBER, 'updating Text node', {
        vnodeSid: vnode.sid,
        before: currentText,
        after: nextText
      });
      // DOMOperations를 통해 업데이트 (AutoTracer에서 추적 가능)
      dom.updateTextContent(domElement, currentText, nextText);
    }
    return;
  }
  
  // 직접 자식 Fiber들의 parent를 현재 domElement로 업데이트 (HTMLElement인 경우만)
  if (domElement instanceof HTMLElement) {
    const prevWasTextOnly =
      prevVNode?.text !== undefined &&
      (!prevVNode.children || prevVNode.children.length === 0);
    const nextHasChildren = Array.isArray(vnode.children) && vnode.children.length > 0;
    if (prevWasTextOnly && nextHasChildren) {
      const textNodes = Array.from(domElement.childNodes).filter(
        node => node.nodeType === Node.TEXT_NODE
      );
      if (textNodes.length > 0) {
        for (const node of textNodes) {
          domElement.removeChild(node);
        }
      }
    }
    
    updateChildFiberParents(fiber, domElement);
  }
  
  // 속성 및 스타일 업데이트 (HTMLElement인 경우만)
  // 최적화: 변경된 경우에만 update 호출
  if (domElement instanceof HTMLElement) {
    if (vnode.attrs) {
      const prevAttrs = prevVNode?.attrs;
      if (!arePropsEqual(prevAttrs, vnode.attrs)) {
        dom.updateAttributes(domElement, prevAttrs, vnode.attrs);
      }
    }
    if (vnode.style) {
      const prevStyle = prevVNode?.style;
      if (!arePropsEqual(prevStyle, vnode.style)) {
        dom.updateStyles(domElement, prevStyle, vnode.style as any);
      }
    }
    
    // Component lifecycle: update when component VNode has stype
    // IMPORTANT: __isReconciling 플래그가 설정되어 있으면 updateComponent를 건너뜀 (무한 루프 방지)
    if (vnode.stype && fiber.effectTag === EffectTag.UPDATE) {
      const isReconciling = !!(context as any)?.__isReconciling;
      
      if (!isReconciling) {
        try {
          components.updateComponent(
            prevVNode || ({} as VNode),
            vnode,
            domElement,
            context || ({} as any)
          );
        } catch (error) {
          logger.error(
            LogCategory.FIBER,
            `Error updating component ${vnode.stype} (sid: ${vnode.sid})`,
            error
          );
        }
      }
    }
  }
  
  // vnode.text 처리 (VNodeBuilder가 text를 collapse한 경우, HTMLElement인 경우만)
  if (domElement instanceof HTMLElement) {
    if (vnode.text !== undefined && (!vnode.children || vnode.children.length === 0)) {
      logger.debug(LogCategory.FIBER, 'handling vnode.text', {
        vnodeSid: vnode.sid,
        text: vnode.text,
        parentTag: domElement.tagName
      });
      handleVNodeTextProperty(domElement, vnode, prevVNode);
      return;
    }
    
    // Root 레벨 model.text 처리 (rootModel이 제공된 경우)
    if (deps.rootModel && deps.rootSid && vnode.sid === deps.rootSid) {
      const model = deps.rootModel;
      if ((model as any)?.text !== undefined && (model as any)?.text !== null) {
        if (!vnode.children || vnode.children.length === 0) {
          const doc = domElement.ownerDocument || document;
          while (domElement.firstChild) domElement.removeChild(domElement.firstChild);
          domElement.appendChild(doc.createTextNode(String((model as any).text)));
          return;
        }
      }
    }
  }
}

/**
 * Stale children 제거
 * 자식 Fiber가 모두 처리된 후에 호출됨
 * 현재 children에 없는 자식 요소를 DOM에서 제거
 * 
 * IMPORTANT: VNode만 순수하게 처리 (decorator 구분 없음)
 */
export function removeStaleChildren(
  fiber: FiberNode,
  deps: FiberReconcileDependencies
): void {
  const host = fiber.domElement;
  if (!host || !(host instanceof HTMLElement)) {
    return;
  }
  
  // IMPORTANT: createFiberTree에서 이미 sid/key/index/tag 기준으로 prevVNode 매칭 완료
  // renderFiberNode에서 각 Fiber child의 domElement가 설정됨
  // commitFiberNode에서 DOM 삽입이 완료됨
  // 따라서 단순히 Fiber child를 순회하면서 사용된 DOM 요소를 추적하면 됨
  // 단, 중첩 구조를 위해 재귀적으로 수집해야 함
  
  // 사용된 DOM 요소 추적 (Fiber child 기준, 재귀적으로)
  const usedDomElements = new Set<HTMLElement | Text>();
  const collectDomElements = (f: FiberNode | null) => {
    while (f) {
      if (f.domElement instanceof HTMLElement || f.domElement instanceof Text) {
        usedDomElements.add(f.domElement);
      }
      // 자식도 재귀적으로 수집 (중첩 구조 처리)
      if (f.child) {
        collectDomElements(f.child);
        }
      f = f.sibling;
    }
  };
  collectDomElements(fiber.child);
  
  // DOM에서 모든 자식 노드 찾기
  const childNodes = Array.from(host.childNodes);
  const components = deps.components;
  const context = deps.context || {};
  
  // 사용되지 않은 DOM 요소 제거
  for (const childNode of childNodes) {
    if (usedDomElements.has(childNode as HTMLElement | Text)) {
      continue; // 사용된 요소는 유지
    }
    
    // 사용되지 않은 DOM 요소 제거
    if (childNode instanceof HTMLElement) {
      // Component unmount (sid가 있는 경우만)
      const sid = childNode.getAttribute(DOMAttribute.BC_SID);
      if (sid) {
        // prevVNode에서 찾아서 unmount
        // React 방식: alternate에서 prevVNode 가져오기
        const prevVNode = fiber.alternate?.vnode || fiber.prevVNode;
        if (prevVNode?.children) {
          const prevChildVNode = prevVNode.children.find(
          (c): c is VNode => {
            if (typeof c !== 'object' || c === null) return false;
            const prevId = getVNodeId(c);
              return prevId === sid;
          }
        );
        if (prevChildVNode && prevChildVNode.stype && prevChildVNode.sid) {
          try {
            components.unmountComponent(prevChildVNode, context);
          } catch (err) {
            logger.error(LogCategory.FIBER, 'Error unmounting component in removeStaleChildren', err);
          }
        }
        }
        }
      }
    
      try {
      host.removeChild(childNode);
      } catch {
        // 이미 제거되었을 수 있음
    }
  }
}

/**
 * Primitive text children 처리
 * 자식 Fiber가 모두 처리된 후에 호출됨
 */
export function processPrimitiveTextChildren(
  fiber: FiberNode,
  deps: FiberReconcileDependencies
): void {
  if (!fiber.primitiveTextChildren || fiber.primitiveTextChildren.length === 0) {
    return;
  }
  
  const host = fiber.domElement;
  if (!host) {
    return;
  }
  
  const vnode = fiber.vnode;
  // React 방식: alternate에서 prevVNode 가져오기
  const prevVNode = fiber.alternate?.vnode || fiber.prevVNode;
  const prevChildVNodes: (VNode | string | number)[] = prevVNode?.children || [];
  
  logger.debug(LogCategory.FIBER, 'processPrimitiveTextChildren start', {
    hostTag: host instanceof HTMLElement ? host.tagName : VNodeTag.TEXT,
    vnodeSid: vnode.sid,
    primitiveCount: fiber.primitiveTextChildren.length,
    prevChildrenCount: prevChildVNodes.length
  });
  
  // 이미 사용된 텍스트 노드를 추적 (중복 방지)
  const usedTextNodes = new Set<Text>();
  
  // 각 primitive text 처리
  // handlePrimitiveTextChild를 사용하여 올바른 위치에 텍스트 노드 생성/업데이트
  // IMPORTANT: primitive text children은 VNode children과 섞여 있어야 하므로,
  // index를 그대로 사용하여 올바른 위치에 삽입해야 함
  // DOM childNodes는 VNode children과 1:1 대응이므로, index를 그대로 사용할 수 있음
  // 하지만 processPrimitiveTextChildren이 자식 Fiber가 모두 처리된 후에 호출되므로,
  // 이미 DOM에 추가된 VNode children을 고려해야 함
  // index 앞에 있는 모든 children (VNode + primitive text)의 DOM 노드 개수 계산
  // VNode children은 이미 DOM에 추가되었으므로, DOM childNodes에서 확인
  // Primitive text는 아직 DOM에 추가되지 않았으므로, VNode children에서만 카운트
  for (const { text, index } of fiber.primitiveTextChildren) {
    logger.debug(LogCategory.FIBER, 'processPrimitiveTextChildren', {
      hostTag: (host as HTMLElement).tagName,
      text,
      index,
      vnodeSid: vnode.sid,
      prevText: prevChildVNodes[index]
    });
    // index 앞에 있는 VNode children의 DOM 노드 개수 계산
    // VNode children은 이미 DOM에 추가되었으므로, DOM childNodes에서 확인
    let domNodeCount = 0;
    if (vnode.children) {
      for (let j = 0; j < index; j++) {
        const prevChild = vnode.children[j];
        if (typeof prevChild === 'object' && prevChild !== null) {
          // VNode는 이미 DOM에 추가되었으므로 카운트
          const childVNode = prevChild as VNode;
          const childDomElement = childVNode.meta?.domElement;
          if (childDomElement && (childDomElement instanceof HTMLElement || childDomElement instanceof Text)) {
            domNodeCount++;
        }
        }
        // Primitive text는 아직 DOM에 추가되지 않았으므로 카운트하지 않음
        // (같은 루프에서 처리되므로)
      }
    }
    
    // handlePrimitiveTextChild를 사용하여 텍스트 노드 처리
    // childIndex는 domNodeCount를 사용 (index 앞에 있는 이미 DOM에 추가된 노드 개수)
    // usedTextNodes를 전달하여 이미 사용된 텍스트 노드 제외
    const textNode = handlePrimitiveTextChild(host, text, domNodeCount, usedTextNodes);
    
    // 사용된 텍스트 노드를 추적에 추가
    usedTextNodes.add(textNode);
  }
}
