import { VNode } from '../../vnode/types';
import { FiberNode } from './types';
import { createFiberTree } from './fiber-tree';
import { FiberScheduler, FiberReconcileFunction } from './fiber-scheduler';
import { FiberPriority } from './types';
import { DOMOperations } from '../../dom-operations';
import { ComponentManager } from '../../component-manager';
import { handlePortalVNode } from '../utils/portal-handler';
import { handleVNodeTextProperty, handlePrimitiveTextChild } from '../utils/text-node-handlers';
import { getVNodeId } from '../utils/vnode-utils';
import {
  transferVNodeIdFromPrev,
  generateVNodeIdIfNeeded,
  findOrCreateHost,
  updateChildFiberParents
} from './fiber-reconciler-helpers';
import { getHostSibling } from './get-host-sibling';
import { isAutoGeneratedSid } from '../../vnode/utils/sid-source';
import { logger, LogCategory } from '../../utils/logger';
import { EffectTag } from './types';
import { VNodeTag, DOMAttribute } from '../../vnode/types';

/**
 * Dependencies required for Fiber reconcile
 */
export interface FiberReconcileDependencies {
  dom: DOMOperations;
  components: ComponentManager;
  currentVisitedPortalIds: Set<string> | null;
  portalHostsById: Map<string, { target: HTMLElement, host: HTMLElement }>;
  // Additional information for root-level processing
  rootModel?: any; // Model reference for model.text processing
  rootSid?: string; // sid of rootVNode
  context?: any; // Reconciliation context (for unmountComponent)
  prevRootFiber?: FiberNode | null; // React-style: previous Fiber tree (used as alternate)
}

/**
 * Check Props changes via shallow comparison
 */
function arePropsEqual(prev: any, next: any): boolean {
  if (prev === next) return true;
  if (!prev || !next) return false;
  
  const prevKeys = Object.keys(prev);
  const nextKeys = Object.keys(next);
  
  if (prevKeys.length !== nextKeys.length) return false;
  
  for (const key of nextKeys) {
    if (prev[key] !== next[key]) return false;
  }
  
  return true;
}

/**
 * Fiber-based reconcile
 * 
 * Convert VNode tree to Fiber tree and process each Fiber node individually
 * 
 * @param container - Root container element
 * @param vnode - VNode tree to reconcile
 * @param prevVNode - Previous VNode (for diffing)
 * @param context - Reconciliation context
 * @param deps - Dependencies required for Fiber reconcile
 * @param onComplete - Callback to be called when Fiber work completes (optional)
 */
export function reconcileWithFiber(
  container: HTMLElement,
  vnode: VNode,
  prevVNode: VNode | undefined,
  context: any,
  deps: FiberReconcileDependencies,
  onComplete?: (rootFiber: FiberNode) => void
): void {
  // React-style: set previous rootFiber as alternate
  const prevRootFiber = deps.prevRootFiber || null;
  
  // 1. Create Fiber tree (pass previous rootFiber as alternate)
  const rootFiber = createFiberTree(container, vnode, prevVNode, context, null, 0, prevRootFiber);
  
  // 2. Define Fiber render function (Render Phase)
  // Only calculate changes for each Fiber node (no DOM manipulation)
  const fiberRender: FiberReconcileFunction = (fiber: FiberNode) => {
    renderFiberNode(fiber, deps, context);
    delete (fiber as any).__isReturningToParent;
  };
  
  // 3. Custom FiberScheduler that sets __isReturningToParent flag when returning to parent
  class CustomFiberScheduler extends FiberScheduler {
    protected performUnitOfWork(fiber: FiberNode): FiberNode | null {
      // 1. Render current Fiber (Render Phase)
      this.reconcileFiber(fiber);
      
      // 2. If child exists, return child (next work)
      if (fiber.child) {
        return fiber.child;
      }
      
      // 3. Return sibling if exists
      if (fiber.sibling) {
        return fiber.sibling;
      }
      
      // 4. Go back to parent and find sibling
      // IMPORTANT: When going back to parent, all children of parent have been processed,
      // so must perform parent's post-processing (remove primitive text, stale decorator)
      let nextFiber = fiber.return;
      while (nextFiber) {
        // When going back to parent, all children of parent have been processed,
        // so call fiberReconcile again on parent to perform post-processing
        // Set __isReturningToParent flag to perform post-processing
        (nextFiber as any).__isReturningToParent = true;
        this.reconcileFiber(nextFiber);
        
        if (nextFiber.sibling) {
          return nextFiber.sibling;
        }
        nextFiber = nextFiber.return;
      }
      
      return null; // Complete
    }
  }
  
  // 4. Start work with Fiber Scheduler (async yield)
  const scheduler = new CustomFiberScheduler(fiberRender, () => {
    // Execute Commit Phase after Render Phase completes
    commitFiberTree(rootFiber, deps, context);
    if (onComplete) {
      onComplete(rootFiber);
    }
  });
  scheduler.scheduleWork(rootFiber, FiberPriority.Normal);
}

/**
 * 단일 Fiber 노드를 render (Render Phase)
 * DOM 조작 없이 변경사항만 계산하고 effectTag 설정
 * 
 * @param fiber - 처리할 Fiber 노드
 * @param deps - 필요한 의존성
 * @param context - Reconciliation context
 */
export function renderFiberNode(
  fiber: FiberNode,
  deps: FiberReconcileDependencies,
  context: any
): void {
  const { dom, components, currentVisitedPortalIds, portalHostsById } = deps;
  
  // Primitive text is not converted to Fiber, so only process VNode here
  const vnode = fiber.vnode;
  // React style: get prevVNode from alternate (fiber.prevVNode is deprecated)
  const prevVNode = fiber.alternate?.vnode || fiber.prevVNode;
  const parent = fiber.parent;
  
  // IMPORTANT: Transfer ID from prevVNode to nextVNode (when ID is missing)
  transferVNodeIdFromPrev(vnode, prevVNode);
  
  // IMPORTANT: When auto-generated sid is needed, use stype and index to generate consistent ID
  generateVNodeIdIfNeeded(vnode, fiber, deps.components);
  
  // 1. Handle Portal
  if (handlePortalVNode(
    vnode,
    dom,
    (host, prev, next, ctx) => {
      // Portal internal reconcile is handled separately
      // Reconcile directly without following Fiber structure
      const portalFiber = createFiberTree(host, next, prev, ctx);
      const portalScheduler = new FiberScheduler((f: FiberNode) => {
        renderFiberNode(f, deps, ctx);
      }, () => {
        // Portal also executes commit phase
        commitFiberTree(portalFiber, deps, ctx);
      });
      portalScheduler.scheduleWork(portalFiber, FiberPriority.Normal);
    },
    currentVisitedPortalIds,
    portalHostsById
  )) {
    // Portal is handled, so exit here
    return;
  }
  
  // 2. If nextVNode is absent, call unmountComponent if prevVNode exists
  if (!vnode || typeof vnode !== 'object') {
    // Call unmountComponent if prevVNode exists and has stype
    if (prevVNode && prevVNode.stype && prevVNode.sid) {
      const prevHost = prevVNode.meta?.domElement;
      if (prevHost && prevHost instanceof HTMLElement) {
        try {
          components.unmountComponent(prevVNode, context);
        } catch (err) {
          logger.error(LogCategory.FIBER, 'Error unmounting component in renderFiberNode', err);
        }
      }
    }
    return;
  }
  
  // If no tag and no text but children exist, add children directly to parent
  // (e.g., when wrapped in root VNode)
  if (!vnode.tag && vnode.children && vnode.children.length > 0) {
    // Fiber scheduler automatically handles children
    // Here, only set DOM element reference (using parent)
      if (!vnode.meta) {
        vnode.meta = {};
      }
    vnode.meta.domElement = parent;
    fiber.domElement = parent;
    
    // 4-1. Update direct child Fibers' parent to current parent
    updateChildFiberParents(fiber, parent);
    
    // Fiber scheduler automatically performs children processing
    return;
    }
  
  // If no tag, no text, and no children, nothing to process
  if (!vnode.tag && !vnode.text) {
    return;
  }
  
  if (vnode.text !== undefined && (!vnode.children || vnode.children.length === 0)) {
    logger.debug(LogCategory.FIBER, 'text vnode detected', {
      sid: vnode.sid,
      tag: vnode.tag,
      text: vnode.text,
      parentTag: parent?.nodeType === 1 ? (parent as HTMLElement).tagName : parent?.nodeName
    });
  }
  
  // 3. Type comparison (reconcile rule: cannot reuse if types differ)
  const isTextVNode = (node: VNode) => node.tag === VNodeTag.TEXT || (!node.tag && node.text !== undefined);
  const isHostVNode = (node: VNode) => node.tag && node.tag !== VNodeTag.TEXT;
  
  const prevType = prevVNode 
    ? (isTextVNode(prevVNode) ? 'text' : isHostVNode(prevVNode) ? 'host' : 'unknown')
    : null;
  const nextType = isTextVNode(vnode) ? 'text' : isHostVNode(vnode) ? 'host' : 'unknown';
  const typeChanged = prevType !== null && prevType !== nextType;
  
  
  // 4. Determine effectTag (calculation only, no DOM manipulation)
  // PLACEMENT if no prevVNode, PLACEMENT if type changed (remove existing DOM then create new), UPDATE otherwise
  if (!prevVNode || typeChanged) {
    fiber.effectTag = EffectTag.PLACEMENT;
  } else {
    fiber.effectTag = EffectTag.UPDATE;
  }
  
  // 5. Create or find DOM element (React style: create DOM in Render Phase)
  // In Render Phase, create DOM but do not insert
  // IMPORTANT: If type changed, do not reuse existing DOM, create new
  let domElement: HTMLElement | Text | null = null;
  
  // Find existing DOM element (from prevVNode, reuse only if type is same)
  if (prevVNode?.meta?.domElement && !typeChanged) {
    domElement = prevVNode.meta.domElement as HTMLElement | Text;
  } else {
    // Create new DOM element (insertion performed in commit phase)
    if (vnode.tag === VNodeTag.TEXT || (!vnode.tag && vnode.text !== undefined)) {
      // Create text node
      const doc = parent.ownerDocument || document;
      const expectedText = String(vnode.text);
      domElement = doc.createTextNode(expectedText);
    } else if (vnode.tag) {
      // Create host element (do not insert)
      const { dom } = deps;
      domElement = dom.createSimpleElement(String(vnode.tag));
      
      // Set VNode identifier attributes
      if (vnode.sid && !isAutoGeneratedSid(vnode)) {
        dom.setAttribute(domElement, DOMAttribute.BC_SID, String(vnode.sid));
      }
      
      // Set attrs (decorator information, etc.)
      if (vnode.attrs) {
        for (const [key, value] of Object.entries(vnode.attrs)) {
          if (value !== undefined && value !== null) {
            dom.setAttribute(domElement, key, String(value));
          }
        }
      }
    }
  }
  
  // Store DOM element reference
  if (!vnode.meta) {
    vnode.meta = {};
  }
  vnode.meta.domElement = domElement;
  fiber.domElement = domElement;
  
  // 7. Primitive text children processing is performed after child Fiber processing
  // (handled in performUnitOfWork when there are no children)
  
  // 8. Child Fiber nodes are automatically handled by FiberScheduler
  // performUnitOfWork returns fiber.child to set as next work

  // React approach: maintain previous state using Fiber tree's alternate instead of prevVNodeTree
  // No separate storage needed
}

/**
 * Commit Fiber tree (Commit Phase)
 * Traverse all Fiber nodes and perform DOM operations according to effectTag
 * 
 * @param rootFiber - Root Fiber node
 * @param deps - Required dependencies
 * @param context - Reconciliation context
 */
export function commitFiberTree(
  rootFiber: FiberNode,
  deps: FiberReconcileDependencies,
  context: any
): void {
  // Traverse Fiber tree and perform commit
  let currentFiber: FiberNode | null = rootFiber;
  
  while (currentFiber) {
    // Commit current Fiber
    commitFiberNode(currentFiber, deps, context);
    
    // If child exists, move to child
    if (currentFiber.child) {
      currentFiber = currentFiber.child;
      continue;
    }
    
    // If no child (all children committed), perform post-processing
    // Process primitive text and remove stale children
    if (currentFiber.primitiveTextChildren && currentFiber.primitiveTextChildren.length > 0) {
      processPrimitiveTextChildren(currentFiber, deps);
    }
    removeStaleChildren(currentFiber, deps);
    
    // If sibling exists, move to sibling
    if (currentFiber.sibling) {
      currentFiber = currentFiber.sibling;
      continue;
    }
    
    // Return to parent to find sibling
    // Also perform parent's post-processing when returning (all children committed)
    let parentFiber = currentFiber.return;
    while (parentFiber && !parentFiber.sibling) {
      // Perform parent's post-processing
      if (parentFiber.primitiveTextChildren && parentFiber.primitiveTextChildren.length > 0) {
        processPrimitiveTextChildren(parentFiber, deps);
      }
      removeStaleChildren(parentFiber, deps);
      
      parentFiber = parentFiber.return;
    }
    if (parentFiber) {
      // Perform parent's post-processing
      if (parentFiber.primitiveTextChildren && parentFiber.primitiveTextChildren.length > 0) {
        processPrimitiveTextChildren(parentFiber, deps);
      }
      removeStaleChildren(parentFiber, deps);
      
      currentFiber = parentFiber.sibling;
    } else {
      currentFiber = null;
    }
  }
}

/**
 * 단일 Fiber 노드를 commit (Commit Phase)
 * effectTag에 따라 DOM 조작 수행
 * 
 * @param fiber - 처리할 Fiber 노드
 * @param deps - 필요한 의존성
 * @param context - Reconciliation context
 */
export function commitFiberNode(
  fiber: FiberNode,
  deps: FiberReconcileDependencies,
  context: any
): void {
  const { dom, components } = deps;
  const vnode = fiber.vnode;
  // React approach: get prevVNode from alternate (fiber.prevVNode is deprecated)
  const prevVNode = fiber.alternate?.vnode || fiber.prevVNode;
  const parent = fiber.parent;
  
  // If no effectTag, do not process
  if (!fiber.effectTag) {
    return;
  }
  
  // Portal is handled separately (already processed in render phase)
  // TODO: Portal should also be moved to commit phase
  
  // If no vnode, handle DELETION
  if (!vnode || typeof vnode !== 'object') {
    if (fiber.effectTag === EffectTag.DELETION && prevVNode) {
      const prevHost = prevVNode.meta?.domElement;
      if (prevHost && prevHost instanceof HTMLElement) {
        try {
          components.unmountComponent(prevVNode, context);
        } catch (err) {
          logger.error(LogCategory.FIBER, 'Error unmounting component in commitFiberNode', err);
        }
        if (prevHost.parentNode) {
          prevHost.parentNode.removeChild(prevHost);
        }
      }
    }
    return;
  }
  
  // If no tag and no text but has children, add children directly to parent
  if (!vnode.tag && vnode.children && vnode.children.length > 0) {
    if (!vnode.meta) {
      vnode.meta = {};
    }
    vnode.meta.domElement = parent;
    fiber.domElement = parent;
    updateChildFiberParents(fiber, parent);
    return;
  }
  
  // If no tag, no text, and no children, nothing to process
  if (!vnode.tag && !vnode.text) {
    return;
  }
  
  // React approach: In Commit Phase, only perform DOM insertion
  // DOM elements are already created in Render Phase, so only insertion is performed here
  const domElement = fiber.domElement;
  
  if (!domElement) {
    // Error if domElement is missing (should be created in Render Phase)
    logger.error(LogCategory.FIBER, 'domElement is not set. Render Phase should create it.');
    return;
  }
  
  // Type comparison (reconcile rule: if type changes, remove existing DOM and insert new)
  const isTextVNode = (node: VNode) => node.tag === VNodeTag.TEXT || (!node.tag && node.text !== undefined);
  const isHostVNode = (node: VNode) => node.tag && node.tag !== VNodeTag.TEXT;
  
  const prevType = prevVNode 
    ? (isTextVNode(prevVNode) ? 'text' : isHostVNode(prevVNode) ? 'host' : 'unknown')
    : null;
  const nextType = isTextVNode(vnode) ? 'text' : isHostVNode(vnode) ? 'host' : 'unknown';
  const typeChanged = prevType !== null && prevType !== nextType;
  
  // If type changed: remove existing DOM
  if (typeChanged && prevVNode?.meta?.domElement) {
    const prevDomElement = prevVNode.meta.domElement;
    if (prevDomElement.parentNode) {
      prevDomElement.parentNode.removeChild(prevDomElement);
    }
    // Component unmount (only for HTMLElement)
    if (prevDomElement instanceof HTMLElement && prevVNode.stype && prevVNode.sid) {
      try {
        components.unmountComponent(prevVNode, context);
      } catch (err) {
        console.error('[Fiber.commitFiberNode] Error unmounting component:', err);
      }
    }
  }
  
  // React's commitPlacement: only perform DOM insertion
  if (fiber.effectTag === EffectTag.PLACEMENT) {
    let actualParent: HTMLElement | null = null;
    let parentCandidate = fiber.parentFiber;
    while (parentCandidate && !actualParent) {
      if (parentCandidate.domElement instanceof HTMLElement) {
        actualParent = parentCandidate.domElement;
        break;
      }
      parentCandidate = parentCandidate.parentFiber;
    }
    if (!actualParent && parent instanceof HTMLElement) {
      actualParent = parent;
    }
    
    // React's getHostSibling: find next sibling's DOM node
    let before = getHostSibling(fiber);
    
    if (!actualParent) {
      logger.error(LogCategory.FIBER, 'actualParent is not available for placement', {
        fiberVNode: {
          sid: vnode.sid,
          tag: vnode.tag,
          text: vnode.text
        },
        parentFiberVNode: fiber.parentFiber?.vnode,
        parentNodeType: parent?.nodeType,
        parentNodeValue: (parent as any)?.nodeValue
      });
      return;
    }
    
    // Check if before node is a child of actualParent
    // In React's commit phase, the next sibling may not have been committed yet,
    // so the before node may not be a child of actualParent
    // In this case, set before to null to handle same as appendChild
    if (before && before.parentNode !== actualParent) {
      before = null;
    }
    
    // DOM insertion (same as React's commitPlacement)
    if (!(actualParent instanceof HTMLElement)) {
      logger.error(LogCategory.FIBER, 'actualParent is not HTMLElement', {
        fiberVNode: {
          sid: vnode.sid,
          tag: vnode.tag,
          text: vnode.text
        },
        parentFiberVNode: {
          sid: fiber.parentFiber?.vnode?.sid,
          tag: fiber.parentFiber?.vnode?.tag,
          text: fiber.parentFiber?.vnode?.text
        },
        parentNodeType: actualParent?.nodeType,
        parentNodeValue: (actualParent as any)?.nodeValue
      });
    }


    if (domElement.parentNode !== actualParent) {
      // If DOM element is not in parent, insert
      actualParent.insertBefore(domElement, before);
    } else if (domElement.nextSibling !== before && before !== domElement) {
      // If DOM element is in parent but at wrong position, move
      actualParent.insertBefore(domElement, before);
    }
    
    // Component lifecycle: mount when component VNode has stype
    // IMPORTANT: do not call mountComponent for already mounted components
    if (domElement instanceof HTMLElement && vnode.stype) {
      const componentManager = components as any;
      let shouldMount = false;
      
      if (vnode.sid) {
        // Check if component is already mounted (check by sid)
          const existingInstance = componentManager.getComponentInstance(vnode.sid);
          // Mount needed if existingInstance is missing or mounted is false or element is different
          if (!existingInstance || !existingInstance.mounted || existingInstance.element !== domElement) {
            shouldMount = true;
          }
      } else {
        // If no sid: check with generateComponentId
        const componentId = componentManager.generateComponentId(vnode, fiber.index);
        if (componentId && typeof componentManager.getComponentInstance === 'function') {
          const existingInstance = componentManager.getComponentInstance(componentId);
          if (!existingInstance || !existingInstance.mounted || existingInstance.element !== domElement) {
            shouldMount = true;
          }
        } else {
          shouldMount = true;
        }
      }
      
      if (shouldMount) {
        try {
          components.mountComponent(vnode, domElement, context || ({} as any));
        } catch (err) {
          logger.error(LogCategory.FIBER, 'Error mounting component', err);
        }
      }
    }
  }
  
  // Store DOM element reference (already set in Render Phase, but ensure it)
  if (!vnode.meta) {
    vnode.meta = {};
  }
  vnode.meta.domElement = domElement;
  
  // Update text node (Text VNode)
  // Reconcile rule: compare prevVNode and nextVNode to update
  if (domElement instanceof Text) {
    const nextText = vnode.text !== undefined ? String(vnode.text) : '';
    const currentText = domElement.textContent || ''; // Current text in actual DOM
    
    // Update if type hasn't changed and text is different
    if (!typeChanged && currentText !== nextText) {
      logger.debug(LogCategory.FIBER, 'updating Text node', {
        vnodeSid: vnode.sid,
        before: currentText,
        after: nextText
      });
      // Update through DOMOperations (traceable in AutoTracer)
      dom.updateTextContent(domElement, currentText, nextText);
    }
    return;
  }
  
  // Update parent of direct child Fibers to current domElement (only if HTMLElement)
  if (domElement instanceof HTMLElement) {
    const prevWasTextOnly =
      prevVNode?.text !== undefined &&
      (!prevVNode.children || prevVNode.children.length === 0);
    const nextHasChildren = Array.isArray(vnode.children) && vnode.children.length > 0;
    if (prevWasTextOnly && nextHasChildren) {
      const textNodes = Array.from(domElement.childNodes).filter(
        node => node.nodeType === Node.TEXT_NODE
      );
      if (textNodes.length > 0) {
        for (const node of textNodes) {
          domElement.removeChild(node);
        }
      }
    }
    
    updateChildFiberParents(fiber, domElement);
  }
  
  // Update attributes and styles (only if HTMLElement)
  // Optimization: only call update if changed
  if (domElement instanceof HTMLElement) {
    if (vnode.attrs) {
      const prevAttrs = prevVNode?.attrs;
      if (!arePropsEqual(prevAttrs, vnode.attrs)) {
        dom.updateAttributes(domElement, prevAttrs, vnode.attrs);
      }
    }
    if (vnode.style) {
      const prevStyle = prevVNode?.style;
      if (!arePropsEqual(prevStyle, vnode.style)) {
        dom.updateStyles(domElement, prevStyle, vnode.style as any);
      }
    }
    
    // Component lifecycle: update when component VNode has stype
    // IMPORTANT: skip updateComponent if __isReconciling flag is set (prevent infinite loop)
    if (vnode.stype && fiber.effectTag === EffectTag.UPDATE) {
      const isReconciling = !!(context as any)?.__isReconciling;
      
      if (!isReconciling) {
        try {
          components.updateComponent(
            prevVNode || ({} as VNode),
            vnode,
            domElement,
            context || ({} as any)
          );
        } catch (error) {
          logger.error(
            LogCategory.FIBER,
            `Error updating component ${vnode.stype} (sid: ${vnode.sid})`,
            error
          );
        }
      }
    }
  }
  
  // Handle vnode.text (when VNodeBuilder collapsed text, only if HTMLElement)
  if (domElement instanceof HTMLElement) {
    if (vnode.text !== undefined && (!vnode.children || vnode.children.length === 0)) {
      logger.debug(LogCategory.FIBER, 'handling vnode.text', {
        vnodeSid: vnode.sid,
        text: vnode.text,
        parentTag: domElement.tagName
      });
      handleVNodeTextProperty(domElement, vnode, prevVNode);
      return;
    }
    
    // Handle root-level model.text (if rootModel is provided)
    if (deps.rootModel && deps.rootSid && vnode.sid === deps.rootSid) {
      const model = deps.rootModel;
      if ((model as any)?.text !== undefined && (model as any)?.text !== null) {
        if (!vnode.children || vnode.children.length === 0) {
          const doc = domElement.ownerDocument || document;
          while (domElement.firstChild) domElement.removeChild(domElement.firstChild);
          domElement.appendChild(doc.createTextNode(String((model as any).text)));
          return;
        }
      }
    }
  }
}

/**
 * Stale children 제거
 * 자식 Fiber가 모두 처리된 후에 호출됨
 * 현재 children에 없는 자식 요소를 DOM에서 제거
 * 
 * IMPORTANT: VNode만 순수하게 처리 (decorator 구분 없음)
 */
export function removeStaleChildren(
  fiber: FiberNode,
  deps: FiberReconcileDependencies
): void {
  const host = fiber.domElement;
  if (!host || !(host instanceof HTMLElement)) {
    return;
  }
  
  // IMPORTANT: prevVNode matching already completed in createFiberTree based on sid/key/index/tag
  // domElement of each Fiber child is set in renderFiberNode
  // DOM insertion is completed in commitFiberNode
  // Therefore, simply track used DOM elements by traversing Fiber children
  // However, must collect recursively to handle nested structures
  
  // Track used DOM elements (based on Fiber children, recursively)
  const usedDomElements = new Set<HTMLElement | Text>();
  const collectDomElements = (f: FiberNode | null) => {
    while (f) {
      if (f.domElement instanceof HTMLElement || f.domElement instanceof Text) {
        usedDomElements.add(f.domElement);
      }
      // Also collect children recursively (handle nested structures)
      if (f.child) {
        collectDomElements(f.child);
        }
      f = f.sibling;
    }
  };
  collectDomElements(fiber.child);
  
  // Find all child nodes in DOM
  const childNodes = Array.from(host.childNodes);
  const components = deps.components;
  const context = deps.context || {};
  
  // Remove unused DOM elements
  for (const childNode of childNodes) {
    if (usedDomElements.has(childNode as HTMLElement | Text)) {
      continue; // Keep used elements
    }
    
    // Remove unused DOM elements
    if (childNode instanceof HTMLElement) {
      // Component unmount (only if sid exists)
      const sid = childNode.getAttribute(DOMAttribute.BC_SID);
      if (sid) {
        // Find in prevVNode and unmount
        // React approach: get prevVNode from alternate
        const prevVNode = fiber.alternate?.vnode || fiber.prevVNode;
        if (prevVNode?.children) {
          const prevChildVNode = prevVNode.children.find(
          (c): c is VNode => {
            if (typeof c !== 'object' || c === null) return false;
            const prevId = getVNodeId(c);
              return prevId === sid;
          }
        );
        if (prevChildVNode && prevChildVNode.stype && prevChildVNode.sid) {
          try {
            components.unmountComponent(prevChildVNode, context);
          } catch (err) {
            logger.error(LogCategory.FIBER, 'Error unmounting component in removeStaleChildren', err);
          }
        }
        }
        }
      }
    
      try {
      host.removeChild(childNode);
      } catch {
        // May have already been removed
    }
  }
}

/**
 * Process primitive text children
 * Called after all child Fibers are processed
 */
export function processPrimitiveTextChildren(
  fiber: FiberNode,
  deps: FiberReconcileDependencies
): void {
  if (!fiber.primitiveTextChildren || fiber.primitiveTextChildren.length === 0) {
    return;
  }
  
  const host = fiber.domElement;
  if (!host) {
    return;
  }
  
  const vnode = fiber.vnode;
  // React approach: get prevVNode from alternate
  const prevVNode = fiber.alternate?.vnode || fiber.prevVNode;
  const prevChildVNodes: (VNode | string | number)[] = prevVNode?.children || [];
  
  logger.debug(LogCategory.FIBER, 'processPrimitiveTextChildren start', {
    hostTag: host instanceof HTMLElement ? host.tagName : VNodeTag.TEXT,
    vnodeSid: vnode.sid,
    primitiveCount: fiber.primitiveTextChildren.length,
    prevChildrenCount: prevChildVNodes.length
  });
  
  // Track already used text nodes (prevent duplicates)
  const usedTextNodes = new Set<Text>();
  
  // Process each primitive text
  // Use handlePrimitiveTextChild to create/update text nodes at correct positions
  // IMPORTANT: primitive text children must be mixed with VNode children,
  // so use index as-is to insert at correct position
  // DOM childNodes correspond 1:1 with VNode children, so can use index as-is
  // However, processPrimitiveTextChildren is called after all child Fibers are processed,
  // so must consider VNode children already added to DOM
  // Calculate DOM node count of all children (VNode + primitive text) before index
  // VNode children are already added to DOM, so check in DOM childNodes
  // Primitive text is not yet added to DOM, so only count VNode children
  for (const { text, index } of fiber.primitiveTextChildren) {
    logger.debug(LogCategory.FIBER, 'processPrimitiveTextChildren', {
      hostTag: (host as HTMLElement).tagName,
      text,
      index,
      vnodeSid: vnode.sid,
      prevText: prevChildVNodes[index]
    });
    // Calculate DOM node count of VNode children before index
    // VNode children are already added to DOM, so check in DOM childNodes
    let domNodeCount = 0;
    if (vnode.children) {
      for (let j = 0; j < index; j++) {
        const prevChild = vnode.children[j];
        if (typeof prevChild === 'object' && prevChild !== null) {
          // VNode is already added to DOM, so count
          const childVNode = prevChild as VNode;
          const childDomElement = childVNode.meta?.domElement;
          if (childDomElement && (childDomElement instanceof HTMLElement || childDomElement instanceof Text)) {
            domNodeCount++;
        }
        }
        // Primitive text is not yet added to DOM, so don't count
        // (processed in same loop)
      }
    }
    
    // Process text node using handlePrimitiveTextChild
    // childIndex uses domNodeCount (number of nodes already added to DOM before index)
    // Pass usedTextNodes to exclude already used text nodes
    const textNode = handlePrimitiveTextChild(host, text, domNodeCount, usedTextNodes);
    
    // Add used text node to tracking
    usedTextNodes.add(textNode);
  }
}
