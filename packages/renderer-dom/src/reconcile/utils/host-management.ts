import { VNode, VNodeTag } from '../../vnode/types';
import { DOMOperations } from '../../dom-operations';
import { isAutoGeneratedSid, markAutoGeneratedSid } from '../../vnode/utils/sid-source';
import { getVNodeId } from './vnode-utils';

/**
 * Component lifecycle manager interface
 * This allows host-management to work with ComponentManager without circular dependencies
 */
export interface ComponentLifecycleManager {
  mountComponent(vnode: VNode, host: HTMLElement, context: any): void;
  updateComponent(prevVNode: VNode, nextVNode: VNode, host: HTMLElement, context: any): void;
}

/**
 * Create a new host element for a child VNode
 * 
 * This function creates a new DOM element and sets up:
 * - VNode identifier attributes (data-bc-sid, data-decorator-*)
 * - Correct position in parent
 * - Component lifecycle (mount)
 * 
 * @param parent - Parent DOM element
 * @param childVNode - Child VNode to create host for
 * @param childIndex - Index where child should be positioned
 * @param dom - DOM operations helper
 * @param components - Component lifecycle manager
 * @param context - Reconciliation context
 * @returns Newly created host element
 */

export function createHostElement(
  parent: HTMLElement,
  childVNode: VNode,
  childIndex: number,
  dom: DOMOperations,
  components: ComponentLifecycleManager,
  context?: any
): HTMLElement {
  // IMPORTANT: This function should not be called if tag is missing or '#text' (handled in reconcileFiberNode branch)
  // If VNodeBuilder doesn't provide tag or provides '#text', reconciler should not arbitrarily create DOM elements
  if (!childVNode.tag || childVNode.tag === VNodeTag.TEXT) {
    throw new Error(
      `[Fiber] createHostElement called with VNode without tag or with '#text' tag. ` +
      `VNodeBuilder must provide a tag for element VNodes. ` +
      `VNode: ${JSON.stringify({ sid: childVNode.sid, stype: childVNode.stype, text: childVNode.text })}`
    );
  }
  
  // IMPORTANT: createHostElement is only called when findOrCreateHost has already tried
  // to find host through findHostForChildVNode and findHostInParentChildren but failed.
  // Therefore, don't search for elements with same ID here, always create new.
  // (Already mounted components would have been found in findHostForChildVNode)
  
  // Create new host element
  // IMPORTANT: tag is already validated above, so always exists
  // createSimpleElement only creates DOM element and doesn't add to parent
  const host = dom.createSimpleElement(String(childVNode.tag));
  
  // Set VNode identifier attributes
  // sid is at top-level (component VNode)
  if (childVNode.sid && !isAutoGeneratedSid(childVNode)) {
    dom.setAttribute(host, 'data-bc-sid', String(childVNode.sid));
  }
  
  // decorator info is stored in attrs (set in VNodeBuilder)
  // Reconciler copies attrs to DOM as is (no domain knowledge)
  // All attributes in attrs are copied to DOM (handled in processChildVNode, but also explicitly handle sid here)
  // decorator attributes are already in attrs, so automatically copied in processChildVNode
  
  // Insert at correct position (childIndex) instead of always appending
  // IMPORTANT: childIndex is index in VNode children, so must use childNodes that includes text nodes
  // However, don't move if host is already at correct position
  const childNodes = Array.from(parent.childNodes);
  const currentIndex = childNodes.indexOf(host);
  
  // Don't move if host is already a child of parent and at correct position
  if (currentIndex !== -1 && currentIndex === childIndex) {
    // Already at correct position
    return host;
  }
  
  // Move if not at correct position
  const referenceNode = childIndex < childNodes.length ? childNodes[childIndex] : null;
  if (referenceNode && referenceNode !== host) {
    parent.insertBefore(host, referenceNode);
  } else if (currentIndex === -1) {
    // Add if host is not a child of parent
    parent.appendChild(host);
  }
  
  // Component lifecycle: mount when component VNode has stype (only process VNode, no decorator distinction)
  // IMPORTANT: don't call mountComponent for already mounted components
  if (childVNode.stype && childVNode.sid) {
    const componentManager = components as any;
    
    // Check if component is already mounted (check by sid)
    if (typeof componentManager.getComponentInstance === 'function') {
      const existingInstance = componentManager.getComponentInstance(childVNode.sid);
      // Don't call mountComponent for already mounted components
      // If existingInstance exists and mounted is true or element equals host, consider it already mounted
      if (existingInstance && (existingInstance.mounted || existingInstance.element === host)) {
        // Already mounted components should call updateComponent,
        // but createHostElement is only called when creating new host, so don't call here
        // updateHostElement calls updateComponent
        return host;
      }
    }
    
    // Mount new component
    try {
      components.mountComponent(childVNode, host, (context as any) || ({} as any));
    } catch (err) {
      // Silently handle mount errors (component should handle its own errors)
    }
  } else if (childVNode.stype && !childVNode.sid) {
    // When sid is missing: generate componentId from ComponentManager
    const componentManager = components as any;
    let componentId: string | undefined;
    if (typeof componentManager.generateComponentId === 'function') {
      // IMPORTANT: For auto-generated sid, use stype and index to generate consistent ID
      componentId = componentManager.generateComponentId(childVNode, childIndex);
    }
    
    if (componentId) {
      // Set sid on VNode (so it can be found in next reconcile)
      markAutoGeneratedSid(childVNode, componentId);
      // Do not expose auto-generated sid to DOM
      
      // Check if component is already mounted
      if (typeof componentManager.getComponentInstance === 'function') {
        const existingInstance = componentManager.getComponentInstance(componentId);
        if (existingInstance && existingInstance.mounted) {
          return host;
        }
      }
      
      // Mount new component
      try {
        components.mountComponent(childVNode, host, (context as any) || ({} as any));
      } catch (err) {
        // Silently handle mount errors (component should handle its own errors)
      }
    }
  }
  
  return host;
}

/**
 * Update existing host element position and attributes
 * 
 * This function ensures an existing host element is:
 * - In the correct parent
 * - At the correct position
 * - Has updated VNode identifier attributes
 * - Has updated component state (if component)
 * 
 * @param host - Existing host element
 * @param parent - Parent DOM element
 * @param childVNode - Child VNode
 * @param childIndex - Index where child should be positioned
 * @param prevChildVNode - Previous child VNode for comparison
 * @param prevChildVNodes - Previous child VNodes array (for finding prevChildVNode)
 * @param dom - DOM operations helper
 * @param components - Component lifecycle manager
 * @param context - Reconciliation context
 */
export function updateHostElement(
  host: HTMLElement,
  parent: HTMLElement,
  childVNode: VNode,
  childIndex: number,
  prevChildVNode: VNode | undefined,
  prevChildVNodes: (VNode | string | number)[],
  dom: DOMOperations,
  components: ComponentLifecycleManager,
  context?: any
): void {
  // Position management: ensure host is in correct parent at correct position
  // IMPORTANT: childIndex is index of VNode children, so must use childNodes which includes text nodes
  const childNodes = Array.from(parent.childNodes);
  if (host.parentElement !== parent) {
    // Host is in different parent, move it
    const referenceNode = childIndex < childNodes.length ? childNodes[childIndex] : null;
    if (referenceNode) {
      parent.insertBefore(host, referenceNode);
    } else {
      parent.appendChild(host);
    }
  } else {
    // Host is in correct parent, but may be in wrong position
    // Move to correct position if needed (reorder will handle this, but we optimize here)
    // IMPORTANT: Must find host's current index from childNodes (not children)
    const currentIndex = childNodes.indexOf(host);
    if (currentIndex !== childIndex) {
      const referenceNode = childIndex < childNodes.length ? childNodes[childIndex] : null;
      if (referenceNode && referenceNode !== host) {
        parent.insertBefore(host, referenceNode);
      }
    }
  }
  
  // Update VNode identifier attributes
  // sid is at top-level (component VNode)
  if (childVNode.sid && !isAutoGeneratedSid(childVNode)) {
    dom.setAttribute(host, 'data-bc-sid', String(childVNode.sid));
  }
  
  // Decorator information is stored in attrs (set by VNodeBuilder)
  // Reconciler copies attrs to DOM as-is (no domain knowledge)
  // All attrs properties are automatically copied in processChildVNode
  
  // Component lifecycle: update when component VNode has stype (process VNode only, no decorator distinction)
  // updateComponent internally calls reconcileFunc, but __isReconciling flag prevents infinite loops
  if (childVNode.stype) {
    // Find prevChildVNode for updateComponent if not provided
    let prevVNodeForUpdate = prevChildVNode;
    if (!prevVNodeForUpdate && childVNode.sid) {
      prevVNodeForUpdate = prevChildVNodes.find(
        (c): c is VNode => typeof c === 'object' && 'sid' in c && c.sid === childVNode.sid
      );
    }
    
    // IMPORTANT: If auto-generated sid is needed, generate consistent ID using stype and index
    // Ensure same ID is used when finding instance in updateComponent
    if (!childVNode.sid && childVNode.stype) {
      const componentManager = components as any;
      if (typeof componentManager.generateComponentId === 'function') {
        const generatedSid = componentManager.generateComponentId(childVNode, childIndex);
        if (generatedSid) {
          markAutoGeneratedSid(childVNode, generatedSid);
        }
      }
    }
    
    // Check if we're already reconciling (prevents infinite loops)
    const isReconciling = !!(context as any)?.__isReconciling;
    
    if (!isReconciling) {
      // Normal update: call updateComponent (which may trigger reconcileFunc)
      try {
        components.updateComponent(
          prevVNodeForUpdate || ({} as VNode),
          childVNode,
          host,
          context || ({} as any)
        );
      } catch (error) {
        console.error(
          `[Reconciler] Error updating component ${childVNode.stype} (sid: ${childVNode.sid}):`,
          error
        );
        throw error;
      }
    } else {
      // Already reconciling: skip component update and DOM attribute/style updates
      // processChildVNode will handle attributes/styles updates to avoid duplication
      // This prevents infinite loops when updateComponent would trigger another reconcile
      // NOTE: Attributes/styles are updated in processChildVNode after updateHostElement returns
    }
  }
}

