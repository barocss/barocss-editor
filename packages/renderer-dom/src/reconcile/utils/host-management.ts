import { VNode, VNodeTag } from '../../vnode/types';
import { DOMOperations } from '../../dom-operations';
import { isAutoGeneratedSid, markAutoGeneratedSid } from '../../vnode/utils/sid-source';
import { getVNodeId } from './vnode-utils';

/**
 * Component lifecycle manager interface
 * This allows host-management to work with ComponentManager without circular dependencies
 */
export interface ComponentLifecycleManager {
  mountComponent(vnode: VNode, host: HTMLElement, context: any): void;
  updateComponent(prevVNode: VNode, nextVNode: VNode, host: HTMLElement, context: any): void;
}

/**
 * Create a new host element for a child VNode
 * 
 * This function creates a new DOM element and sets up:
 * - VNode identifier attributes (data-bc-sid, data-decorator-*)
 * - Correct position in parent
 * - Component lifecycle (mount)
 * 
 * @param parent - Parent DOM element
 * @param childVNode - Child VNode to create host for
 * @param childIndex - Index where child should be positioned
 * @param dom - DOM operations helper
 * @param components - Component lifecycle manager
 * @param context - Reconciliation context
 * @returns Newly created host element
 */

export function createHostElement(
  parent: HTMLElement,
  childVNode: VNode,
  childIndex: number,
  dom: DOMOperations,
  components: ComponentLifecycleManager,
  context?: any
): HTMLElement {
  // IMPORTANT: tag가 없거나 '#text'이면 이 함수를 호출하면 안 됨 (reconcileFiberNode에서 분기 처리)
  // VNodeBuilder가 tag를 제공하지 않거나 '#text'로 제공하면 reconciler가 임의로 DOM 요소를 생성하면 안 됨
  if (!childVNode.tag || childVNode.tag === VNodeTag.TEXT) {
    throw new Error(
      `[Fiber] createHostElement called with VNode without tag or with '#text' tag. ` +
      `VNodeBuilder must provide a tag for element VNodes. ` +
      `VNode: ${JSON.stringify({ sid: childVNode.sid, stype: childVNode.stype, text: childVNode.text })}`
    );
  }
  
  // IMPORTANT: findOrCreateHost에서 이미 findHostForChildVNode와 findHostInParentChildren을 통해
  // host를 찾았는데 찾지 못했을 때만 createHostElement를 호출합니다.
  // 따라서 여기서는 같은 ID를 가진 요소를 찾지 않고, 항상 새로 생성해야 합니다.
  // (이미 마운트된 컴포넌트는 findHostForChildVNode에서 찾았을 것입니다)
  
  // Create new host element
  // IMPORTANT: tag는 위에서 이미 검증되었으므로 항상 존재함
  // createSimpleElement는 DOM 요소만 생성하고 parent에 추가하지 않음
  const host = dom.createSimpleElement(String(childVNode.tag));
  
  // Set VNode identifier attributes
  // sid는 top-level에 있음 (component VNode)
  if (childVNode.sid && !isAutoGeneratedSid(childVNode)) {
    dom.setAttribute(host, 'data-bc-sid', String(childVNode.sid));
  }
  
  // decorator 정보는 attrs에 저장됨 (VNodeBuilder에서 설정)
  // Reconciler는 attrs를 그대로 DOM에 복사 (domain 지식 없음)
  // attrs의 모든 속성을 DOM에 복사 (processChildVNode에서 처리되지만, 여기서도 sid만 명시적으로 처리)
  // decorator 속성은 attrs에 이미 있으므로 processChildVNode에서 자동으로 복사됨
  
  // Insert at correct position (childIndex) instead of always appending
  // IMPORTANT: childIndex는 VNode children의 인덱스이므로, text nodes도 포함하는 childNodes를 사용해야 함
  // 하지만 host가 이미 올바른 위치에 있으면 이동하지 않음
  const childNodes = Array.from(parent.childNodes);
  const currentIndex = childNodes.indexOf(host);
  
  // host가 이미 parent의 자식이고 올바른 위치에 있으면 이동하지 않음
  if (currentIndex !== -1 && currentIndex === childIndex) {
    // 이미 올바른 위치에 있음
    return host;
  }
  
  // 올바른 위치에 없으면 이동
  const referenceNode = childIndex < childNodes.length ? childNodes[childIndex] : null;
  if (referenceNode && referenceNode !== host) {
    parent.insertBefore(host, referenceNode);
  } else if (currentIndex === -1) {
    // host가 parent의 자식이 아니면 추가
    parent.appendChild(host);
  }
  
  // Component lifecycle: mount when component VNode has stype (VNode만 처리, decorator 구분 없음)
  // IMPORTANT: 이미 마운트된 컴포넌트는 mountComponent를 호출하지 않음
  if (childVNode.stype && childVNode.sid) {
    const componentManager = components as any;
    
    // 이미 마운트된 컴포넌트인지 확인 (sid로 확인)
    if (typeof componentManager.getComponentInstance === 'function') {
      const existingInstance = componentManager.getComponentInstance(childVNode.sid);
      // 이미 마운트된 컴포넌트는 mountComponent를 호출하지 않음
      // existingInstance가 있고 mounted가 true이거나 element가 host와 같으면 이미 마운트된 것으로 간주
      if (existingInstance && (existingInstance.mounted || existingInstance.element === host)) {
        // 이미 마운트된 컴포넌트는 updateComponent를 호출해야 하지만,
        // createHostElement는 새로운 host를 생성할 때만 호출되므로 여기서는 호출하지 않음
        // updateHostElement에서 updateComponent를 호출함
        return host;
      }
    }
    
    // 새 컴포넌트 마운트
    try {
      components.mountComponent(childVNode, host, (context as any) || ({} as any));
    } catch (err) {
      // Silently handle mount errors (component should handle its own errors)
    }
  } else if (childVNode.stype && !childVNode.sid) {
    // sid가 없는 경우: ComponentManager에서 componentId 생성
    const componentManager = components as any;
    let componentId: string | undefined;
    if (typeof componentManager.generateComponentId === 'function') {
      // IMPORTANT: 자동 생성 sid의 경우, stype과 index를 사용하여 일관된 ID 생성
      componentId = componentManager.generateComponentId(childVNode, childIndex);
    }
    
    if (componentId) {
      // VNode에 sid 설정 (다음 reconcile에서 찾을 수 있도록)
      markAutoGeneratedSid(childVNode, componentId);
      // auto-generated sid는 DOM에 노출하지 않음
      
      // 이미 마운트된 컴포넌트인지 확인
      if (typeof componentManager.getComponentInstance === 'function') {
        const existingInstance = componentManager.getComponentInstance(componentId);
        if (existingInstance && existingInstance.mounted) {
          return host;
        }
      }
      
      // 새 컴포넌트 마운트
      try {
        components.mountComponent(childVNode, host, (context as any) || ({} as any));
      } catch (err) {
        // Silently handle mount errors (component should handle its own errors)
      }
    }
  }
  
  return host;
}

/**
 * Update existing host element position and attributes
 * 
 * This function ensures an existing host element is:
 * - In the correct parent
 * - At the correct position
 * - Has updated VNode identifier attributes
 * - Has updated component state (if component)
 * 
 * @param host - Existing host element
 * @param parent - Parent DOM element
 * @param childVNode - Child VNode
 * @param childIndex - Index where child should be positioned
 * @param prevChildVNode - Previous child VNode for comparison
 * @param prevChildVNodes - Previous child VNodes array (for finding prevChildVNode)
 * @param dom - DOM operations helper
 * @param components - Component lifecycle manager
 * @param context - Reconciliation context
 */
export function updateHostElement(
  host: HTMLElement,
  parent: HTMLElement,
  childVNode: VNode,
  childIndex: number,
  prevChildVNode: VNode | undefined,
  prevChildVNodes: (VNode | string | number)[],
  dom: DOMOperations,
  components: ComponentLifecycleManager,
  context?: any
): void {
  // Position management: ensure host is in correct parent at correct position
  // IMPORTANT: childIndex는 VNode children의 인덱스이므로, text nodes도 포함하는 childNodes를 사용해야 함
  const childNodes = Array.from(parent.childNodes);
  if (host.parentElement !== parent) {
    // Host is in different parent, move it
    const referenceNode = childIndex < childNodes.length ? childNodes[childIndex] : null;
    if (referenceNode) {
      parent.insertBefore(host, referenceNode);
    } else {
      parent.appendChild(host);
    }
  } else {
    // Host is in correct parent, but may be in wrong position
    // Move to correct position if needed (reorder will handle this, but we optimize here)
    // IMPORTANT: childNodes에서 host의 현재 인덱스를 찾아야 함 (children이 아닌)
    const currentIndex = childNodes.indexOf(host);
    if (currentIndex !== childIndex) {
      const referenceNode = childIndex < childNodes.length ? childNodes[childIndex] : null;
      if (referenceNode && referenceNode !== host) {
        parent.insertBefore(host, referenceNode);
      }
    }
  }
  
  // Update VNode identifier attributes
  // sid는 top-level에 있음 (component VNode)
  if (childVNode.sid && !isAutoGeneratedSid(childVNode)) {
    dom.setAttribute(host, 'data-bc-sid', String(childVNode.sid));
  }
  
  // decorator 정보는 attrs에 저장됨 (VNodeBuilder에서 설정)
  // Reconciler는 attrs를 그대로 DOM에 복사 (domain 지식 없음)
  // attrs의 모든 속성은 processChildVNode에서 자동으로 복사됨
  
  // Component lifecycle: update when component VNode has stype (VNode만 처리, decorator 구분 없음)
  // updateComponent internally calls reconcileFunc, but __isReconciling flag prevents infinite loops
  if (childVNode.stype) {
    // Find prevChildVNode for updateComponent if not provided
    let prevVNodeForUpdate = prevChildVNode;
    if (!prevVNodeForUpdate && childVNode.sid) {
      prevVNodeForUpdate = prevChildVNodes.find(
        (c): c is VNode => typeof c === 'object' && 'sid' in c && c.sid === childVNode.sid
      );
    }
    
    // IMPORTANT: 자동 생성 sid가 필요한 경우, stype과 index를 사용하여 일관된 ID 생성
    // updateComponent에서 instance를 찾을 때도 같은 ID를 사용하도록 보장
    if (!childVNode.sid && childVNode.stype) {
      const componentManager = components as any;
      if (typeof componentManager.generateComponentId === 'function') {
        const generatedSid = componentManager.generateComponentId(childVNode, childIndex);
        if (generatedSid) {
          markAutoGeneratedSid(childVNode, generatedSid);
        }
      }
    }
    
    // Check if we're already reconciling (prevents infinite loops)
    const isReconciling = !!(context as any)?.__isReconciling;
    
    if (!isReconciling) {
      // Normal update: call updateComponent (which may trigger reconcileFunc)
      try {
        components.updateComponent(
          prevVNodeForUpdate || ({} as VNode),
          childVNode,
          host,
          context || ({} as any)
        );
      } catch (error) {
        console.error(
          `[Reconciler] Error updating component ${childVNode.stype} (sid: ${childVNode.sid}):`,
          error
        );
        throw error;
      }
    } else {
      // Already reconciling: skip component update and DOM attribute/style updates
      // processChildVNode will handle attributes/styles updates to avoid duplication
      // This prevents infinite loops when updateComponent would trigger another reconcile
      // NOTE: Attributes/styles are updated in processChildVNode after updateHostElement returns
    }
  }
}

