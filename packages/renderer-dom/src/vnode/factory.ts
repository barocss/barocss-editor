// Registry and VNode types
import { VNode, VNodeTag, DOMAttribute } from './types';

// Utility functions for template processing
import { splitTextByMarks, TextRun } from './utils/marks';     // Text mark processing
import { getSid, getMarks, getDataValue, extractNodeId } from './utils/model-data';
import { resolveAttributeValue, resolveStyleObject, resolveClassName } from './utils/attribute-resolution';
import { assignComponentIdentityAttrs, createComponentWrapperAttrs } from './utils/component-identity';
import { initializeElementVNode } from './utils/element-initialization';
import { shouldCollapseTextChild, applyTextCollapse } from './utils/text-collapse';
import { logger, LogCategory } from '../utils/logger';
import { applyComponentIdentity } from './utils/component-identity-application';
import { resolveComponentPropsAndKey } from './utils/component-props-resolution';
import { resolveDecoratorsFromBuildOptions, prepareComponentWrapperData } from './utils/component-wrapper';
import { DecoratorProcessor, Decorator, VNodeBuildOptions } from './decorator';
import { PatternDecoratorGenerator } from './pattern-decorator-generator';
import { CustomDecoratorGeneratorManager } from './custom-decorator-generator';
import { markAutoGeneratedSid } from './utils/sid-source';
import { getBuildInProgressFlag, setBuildInProgressFlag, clearBuildInProgressFlag } from './utils/build-guard';
import {
  ComponentProps,
  ComponentTemplate,
  ConditionalTemplate,
  DataTemplate,
  EachTemplate,
  ElementTemplate,
  getGlobalRegistry,
  ModelData,
  PortalTemplate,
  RendererRegistry,
  SlotTemplate
} from '@barocss/dsl'; // Global registry access
import type { ComponentContext } from '../types';
import type { ComponentManager } from '../component-manager';

// Re-export decorator types for backward compatibility
export type { Decorator, VNodeBuildOptions } from './decorator';

// Import props resolution utilities
import {
  sanitizeProps as sanitizePropsUtil,
  resolveComponentProps
} from './props-resolution';
import {
  attachComponentInfo,
  attachComponentInfoWithSeparatedData
} from './component-info';
// Import template type guards
import {
  isComponentTemplate,
  isDataTemplate,
  isSlotTemplate,
  isEachTemplate,
  isConditionalTemplate,
  isPortalTemplate,
  isExternalComponent
} from './utils/template-guards';
// Import VNode type guards
import {
  isVNode,
  isDecoratorNode
} from './utils/vnode-guards';
// Import type check utilities
import {
  isFunction,
  isString,
  isStringOrNumber,
  isObject,
  isBoolean,
  isDefined,
  isNullOrUndefined,
  isNonEmptyArray,
  isEventHandler,
  isStyleObject
} from './utils/type-checks';
// Import VNode creation utilities
import {
  createTextVNode,
  createElementVNode,
  createComponentVNode,
  createSpanWrapper,
  createMarkWrapper
} from './utils/vnode-creators';

/**
 * VNodeBuilder: converts Templates into VNodes
 * 
 * This class is responsible for converting DSL templates (ElementTemplate, ComponentTemplate, etc.)
 * into VNode objects that can be rendered to the DOM. It handles:
 * 
 * - Template resolution: Looks up renderer templates in the registry
 * - Data binding: Resolves data() functions and dynamic attributes
 * - DSL normalization: Converts each/slot/component constructs into VNode trees
   * - Component management: Handles external components and registered components
 * - Mixed content: Properly handles elements with both child elements and text content
 * 
 * The VNodeBuilder works in conjunction with the reconcile system to provide
 * efficient DOM updates and component lifecycle management.
 */
/**
 * Component state provider interface for VNodeBuilder
 * Allows VNodeBuilder to access component state during build without circular dependency
 */
export interface ComponentStateProvider {
  /**
   * Generate component ID from VNode
   */
  generateComponentId(vnode: VNode): string;

  /**
   * Get component state by component ID
   */
  getComponentState(componentId: string): Record<string, any>;

  /**
   * Get component state by VNode (convenience method)
   */
  getComponentStateByVNode(vnode: VNode): Record<string, any>;
}

export class VNodeBuilder {
  /** Registry for looking up renderer templates and components */
  private registry: RendererRegistry = getGlobalRegistry();

  /** Decorator processor for handling decorator-related operations */
  private decoratorProcessor: DecoratorProcessor;

  /** Component state provider (optional) - injected from ComponentManager */
  private componentStateProvider?: ComponentStateProvider;

  /** ComponentManager instance (for accessing component instances) */
  private componentManager?: ComponentManager;

  /** Pattern decorator generator (optional) */
  private patternDecoratorGenerator?: PatternDecoratorGenerator;

  /** Custom decorator generator manager (optional) */
  private customDecoratorGeneratorManager?: CustomDecoratorGeneratorManager;

  /** Current build options (set during build() call) */
  private currentBuildOptions?: VNodeBuildOptions;

  /** Set of used IDs to prevent conflicts in data-bc-sid attributes */
  private usedIds = new Set<string>();

  constructor(
    registry?: RendererRegistry,
    options?: {
      componentStateProvider?: ComponentStateProvider;
      componentManager?: ComponentManager;
      patternDecoratorGenerator?: PatternDecoratorGenerator;
      customDecoratorGeneratorManager?: CustomDecoratorGeneratorManager;
    }
  ) {
    // Use global registry if none provided
    if (registry) {
      this.registry = registry;
    }
    this.decoratorProcessor = new DecoratorProcessor(this.registry);
    this.componentStateProvider = options?.componentStateProvider;
    this.componentManager = options?.componentManager;
    this.patternDecoratorGenerator = options?.patternDecoratorGenerator;
    this.customDecoratorGeneratorManager = options?.customDecoratorGeneratorManager;
  }

  /**
   * Ensures unique ID generation to prevent conflicts
   * 
   * This method tracks used IDs and generates unique variants when conflicts occur.
   * It's used to prevent duplicate data-bc-sid attributes in the DOM.
   * 
   * @param id - The base ID to make unique
   * @returns Unique ID if input was provided, undefined otherwise
   */
  private ensureUniqueId(id: string | undefined): string | undefined {
    if (!id) return undefined;

    // Assuming IDs are unique in Model, only output warn on duplicate detection
    if (this.usedIds.has(id)) {
      console.warn(`[VNodeBuilder] Duplicate ID detected: "${id}". Model should ensure unique IDs.`);
    }

    this.usedIds.add(id);
    return id;
  }

  /**
   * Helper method to get component state from ComponentManager if available
   * Creates a temporary VNode to generate componentId, then retrieves state
   */
  private _getComponentStateForBuild(template: ComponentTemplate, data: ModelData, props: Record<string, any>): Record<string, any> {
    if (!this.componentStateProvider) {
      return {};
    }

    // Create temporary VNode to generate componentId
    const tempVNode = createComponentVNode({
      stype: template.name,
      props
    });

    try {
      return this.componentStateProvider.getComponentStateByVNode(tempVNode);
    } catch (error) {
      console.warn('[VNodeBuilder] Failed to get component state:', error);
      return {};
    }
  }

  /**
   * Creates a component context for inline components
   * 
   * This method creates a ComponentContext object that provides:
   * - Component ID and state management
   * - Props access
   * - Registry reference
   * - State management methods (initState, getState, setState, toggleState)
   * 
   * The context is used by inline components to access their state and props
   * and to trigger re-renders when state changes.
   * 
   * @param id - Unique identifier for the component
   * @param state - Current component state
   * @param props - Component props
   * @param overrides - Optional overrides for context methods
   * @returns ComponentContext object
   */
  private _makeContext(
    id: string,
    state: Record<string, any>,
    props: ComponentProps,
    model: ModelData,
    overrides?: Record<string, any> & { instance?: any }
  ): ComponentContext {
    const base: ComponentContext = {
      id,
      get state() { return state; }, // Dynamic state access
      props: props, // props are already sanitized values (excluding stype/sid)
      model: model, // model is original as is (including stype/sid)
      registry: this.registry,
      initState: (initial: Record<string, any>) => {
        // Initialize state if not already initialized
        if (!state._initialized) {
          Object.assign(state, initial, { _initialized: true });
        }
      },
      getState: (key: string) => state[key],
      setState: (_newState: Record<string, any>) => {
        // For VNodeBuilder context, setState is a no-op
        // Real state management happens in registerContextComponent
        // This prevents infinite loops during template building
      },
      toggleState: (_key: string) => {
        // For VNodeBuilder context, toggleState is a no-op
        // Real state management happens in registerContextComponent
        // This prevents infinite loops during template building
      }
    };

    // Spread operator or Object.assign removes getters,
    // so use Object.defineProperty to preserve getters
    const result: any = {};

    // Copy base's regular properties
    Object.keys(base).forEach(key => {
      if (key !== 'state') {
        result[key] = (base as any)[key];
      }
    });

    // Copy overrides' regular properties
    if (overrides) {
      Object.keys(overrides).forEach(key => {
        if (key !== 'state' && key !== 'instance') {
          result[key] = (overrides as any)[key];
        }
      });
    }

    // Set instance directly (use if in overrides)
    if (overrides?.instance) {
      result.instance = overrides.instance;
    }

    // Set state getter: use base's state getter (can override later if state exists in overrides)
    Object.defineProperty(result, 'state', {
      get: () => state,
      enumerable: true,
      configurable: true
    });

    return result;
  }

  getRegistry(): RendererRegistry {
    return this.registry;
  }


  /**
   * Main entry point for building VNodes from node types
   * 
   * This method looks up the renderer for the given nodeType and builds a VNode
   * by processing the renderer's template with the provided data.
   * 
   * @param nodeType - The type of node to build (must be registered in the registry)
   * @param data - Model data to use for data binding and template evaluation
   * @param options - Optional configuration including decorators and sid
   * @returns VNode ready for DOM rendering
   * @throws Error if no renderer is found for the nodeType
   */
  build(nodeType: string, data: ModelData = {}, options?: VNodeBuildOptions): VNode {
    const isNestedBuild = getBuildInProgressFlag();
    let didSetFlag = false;
    if (!isNestedBuild) {
      setBuildInProgressFlag(true);
      didSetFlag = true;
    }
    // Store build options for internal use
    const isTopLevel = !this.currentBuildOptions;
    this.currentBuildOptions = options;

    // Clear used IDs only for top-level build to allow reuse of IDs across renders
    // Recursive calls (e.g., from _renderSlotGetChildren) should not clear usedIds
    if (isTopLevel) {
      this.usedIds.clear();
    }
    if (isNullOrUndefined(data)) {
      throw new Error('Data cannot be null or undefined');
    }

    // Everything defined with define() can only be component
    // Can only retrieve with getComponent() (get() is legacy)
    const component = this.registry.getComponent?.(nodeType);
    if (!component) {
      throw new Error(`Component for node type '${nodeType}' not found. All components must be registered via define().`);
    }

    // component is ExternalComponent type
    // - template?: ContextualComponent - component function
    // - managesDOM?: boolean - whether DOM is managed
    // - mount, update, unmount - lifecycle methods

    let vnode: VNode | null;

    // External component (managesDOM === true)
    if (component.managesDOM === true) {
      vnode = this._buildExternalComponent(nodeType, component, data, options);
    } else {
      // Context component (managesDOM === false or undefined)
      vnode = this._buildContextComponentFromFunction(nodeType, component, data, options);
    }
    if (!vnode) {
      throw new Error(`Failed to build VNode for node type '${nodeType}'`);
    }

    // 
    // Important: decorator processing is performed at each child build time (unidirectional build principle)
    // - _processEachTemplateChild: decorator processing when building each item of each template
    // - _processComponentChild: decorator processing when building ComponentTemplate
    // - _processElementTemplateChild: decorator processing when building ElementTemplate
    // 
    // All children are processed with decorators at build time,
    // so _processDecoratorsForChildren is no longer needed (removed)
    // 
    // Recursive nested children processing is automatically handled at each child build time
    // (when building each child, that child's children are also built, and decorators are processed together)

    // Clear build options after build completes
    this.currentBuildOptions = undefined;
    if (didSetFlag) {
      clearBuildInProgressFlag();
    }

    // Log: VNode build result
    if (isTopLevel) {
      const buildInfo = {
        nodeType,
        sid: vnode.sid,
        stype: vnode.stype,
        tag: vnode.tag,
        hasText: vnode.text !== undefined,
        textPreview: vnode.text ? String(vnode.text).slice(0, 50) : undefined,
        childrenCount: Array.isArray(vnode.children) ? vnode.children.length : 0,
        vnodeTree: this.serializeVNodeTree(vnode, 0, 3) // Maximum 3 levels deep
      };
    }

    return vnode;
  }

  /**
   * Serialize VNode tree for log output
   * Limit depth to prevent circular references
   */
  private serializeVNodeTree(vnode: VNode, depth: number = 0, maxDepth: number = 3): any {
    if (depth > maxDepth) {
      return { _truncated: true };
    }
    
    const result: any = {
      tag: vnode.tag,
      sid: vnode.sid,
      stype: vnode.stype,
      text: vnode.text !== undefined ? String(vnode.text).slice(0, 50) : undefined,
      childrenCount: Array.isArray(vnode.children) ? vnode.children.length : 0
    };
    
    // Add attrs info (especially class info)
    if (vnode.attrs) {
      const classAttr = vnode.attrs.class || vnode.attrs.className;
      if (classAttr) {
        result.class = String(classAttr).slice(0, 100);
      }
    }
    
    // Serialize deeper for text-bold-italic nodes
    const actualMaxDepth = (vnode.sid === 'text-bold-italic' || depth === 0) ? 10 : maxDepth;
    
    if (Array.isArray(vnode.children) && vnode.children.length > 0 && depth < actualMaxDepth) {
      result.children = vnode.children.slice(0, 10).map((child, idx) => {
        if (typeof child === 'string' || typeof child === 'number') {
          return { type: 'text', value: String(child).slice(0, 30) };
        }
        if (typeof child === 'object' && child) {
          return this.serializeVNodeTree(child as VNode, depth + 1, actualMaxDepth);
        }
        return { type: 'unknown', value: child };
      });
      if (vnode.children.length > 10) {
        result.children.push({ _more: `${vnode.children.length - 10} more children` });
      }
    }
    
    return result;
  }

  /**
   * Builds a nested VNode for a single marked text run
   * 
   * This method creates a nested structure of VNodes representing a text run
   * with mark annotations. It builds the structure from inside-out, wrapping
   * the text with mark elements in the order specified by run.types.
   * 
   * Example: For text "Hello" with marks [bold, italic], it creates:
   * <em><strong>Hello</strong></em>
   * 
   * @param run - The text run with mark annotations
   * @param model - Model data for mark attribute resolution
   * @returns VNode representing the marked text run
   */
  private _buildMarkedRunVNode(run: TextRun, model: ModelData): VNode {
    const activeTypes: string[] = Array.isArray(run?.types) ? run.types as string[] : [];
    // innermost content: wrap text in span to simplify reconciler processing
    // Optimization for editor focus: always wrap text-only VNode in span
    let inner: VNode = createSpanWrapper([
      createTextVNode(run?.text ?? '')
    ]);

    // Always nest overlapping marks in the order given by run.types
    let typesToApply: string[] = activeTypes;

    // Wrap using selected types from inner to outer
    for (let i = typesToApply.length - 1; i >= 0; i--) {
      const t = typesToApply[i];
      let markTmpl = this.registry.getMarkRenderer?.(t);
      // pick attrs from the model's overlapping mark of this type
      let activeMark: any = undefined;
      if (Array.isArray((model as any)?.marks)) { // Keep Array.isArray (for type checking)
        const nodeMarks = (model as any).marks as Array<any>;
        activeMark = nodeMarks.find((m: any) => {
          if (!m) return false;
          // Mark type uses stype field (maintain consistency with IMark interface)
          const markStype = m.stype;
          if (markStype !== t) return false;
          // Marks without range apply to entire text, so always match
          if (!m.range) return true;
          const s = Math.max(0, m.range[0] ?? 0);
          const e = Math.max(0, m.range[1] ?? 0);
          return Math.max(s, (run as any).start ?? 0) < Math.min(e, (run as any).end ?? 0);
        });
      }

      const props = {
        text: String(run?.text ?? ''),
        attributes: (activeMark?.attributes != null ? activeMark.attributes : activeMark?.attrs) || undefined,
        run: {
          start: (run as any).start,
          end: (run as any).end,
          types: (run as any).types,
          classes: (run as any).classes
        },
        model
      } as any;

      // getMarkRenderer() only returns ComponentTemplate (defined with define())
      // defineMark() uses define(), so always returns ComponentTemplate only
      if (markTmpl && isComponentTemplate(markTmpl)) {
        // Component template: execute component function to get ElementTemplate
        const compTmpl = markTmpl as ComponentTemplate;
        if (isFunction(compTmpl.component)) {
          // Create minimal context for mark renderer
          // For mark renderer, props also act as model
          const markProps = sanitizePropsUtil(props || {});
          const markModel = (props || {}) as ModelData;
          const ctx: any = this._makeContext(`__mark_${t}`, {}, markProps, markModel, {});
          const elementTemplate = compTmpl.component(markProps, markModel, ctx) as ElementTemplate;
          if (elementTemplate && elementTemplate.type === 'element') {
            // elementTemplate.attributes is props
            // Use props as model (for mark renderer)
            inner = this._buildElement(elementTemplate, props || {} as ModelData, {
              injectChild: inner,
              useDataAsSlot: true
            });
            continue;
          }
        }
        // Fallback: try _buildComponent
        const built = this._buildComponent(markTmpl as ComponentTemplate, props, {
          injectChild: inner, useDataAsSlot: true
        });
        if (built) {
          inner = built as VNode;
          continue;
        }
      }

      // When mark renderer is not defined: handle with default span
      // Tag mapping for mark types is responsibility of schema/template definition, so renderer-dom doesn't handle it
      // t comes from run.types, so should always be valid string
      inner = createMarkWrapper('span', `mark-${t}`, inner);
    }

    // If no active types but classes exist (e.g., renderer wants class marks), return a span wrapper
    // IMPORTANT: run.classes can now be empty (mark-{type} auto-add removed)
    // Therefore, don't use this fallback
    // if (activeTypes.length === 0 && isNonEmptyArray(run?.classes)) {
    //   return createElementVNode(
    //     'span',
    //     { className: run.classes.join(' ') },
    //     [createTextVNode(run?.text ?? '')]
    //   );
    // }

    // innermost is already wrapped in span, so additional wrapping is unnecessary
    return inner;
  }

  /**
   * Builds a VNode from an ElementTemplate
   * 
   * ElementTemplate structure: element('div', { className: 'test' }, [])
   * - template.tag: tag name ('div')
   * - template.attributes: props (props at template definition time, { className: 'test' })
   * - template.children: child elements
   * 
   * This is the core method for converting ElementTemplate objects into VNodes.
   * It handles:
   * 
   * - Dynamic tag resolution (if tag is a function)
   * - Attribute processing (template.attributes is props)
   * - Data binding (data is model, used for data('text'), data('content'), etc.)
   * - Child element processing (elements, text, data bindings, slots, etc.)
   * - Mixed content handling (elements with both child elements and text)
   * - Component resolution for registered component tags
   * 
   * @param template - ElementTemplate to build (template.attributes is props)
   * @param data - Model data (runtime model data, used for data('text'), data('content'), etc.)
   * @param options - Optional configuration for special cases
   *   - injectChild: VNode to inject when useDataAsSlot is true
   *   - useDataAsSlot: Whether to treat data('text') as an implicit slot
   *   - decorators: Decorator data array for this node
   *   - sid: Current node sid for decorator matching
   * @returns VNode representing the element
   */
  private _buildElement(
    template: ElementTemplate,  // template.attributes is props
    data: ModelData,  // model (runtime data)
    options?: { injectChild?: VNode; useDataAsSlot?: boolean; decorators?: Decorator[]; sid?: string }
  ): VNode {
    // Merge current build options with provided options
    const buildOptions = this._mergeBuildOptions(options, getSid(data));

    // Initialize VNode with tag, attrs, and key
    // template.attributes is props, data is model
    const vnode = initializeElementVNode(template, data);

    // Apply template attributes (props) and data bindings (model)
    // template.attributes: props at template definition time
    // data: runtime model data
    this._applyElementAttributes(vnode, template, data);

    // Process children and build ordered children array
    // template.children: children at template definition time
    // data: runtime model data (data('text'), data('content'), etc.)
    let { orderedChildren, hasDataTextProcessed } = this._processElementChildren(template, data, vnode, buildOptions);

    // Remove meaningless span wrappers (e.g., leftover empty spans from decorator splits)
    // These can appear when decorator boundaries align in a way that produces zero-length runs.
    // We only prune spans that carry no sid/decorator identity, no attrs/styles, no text, and no children.
    if (orderedChildren.length > 0) {
      const pruned = orderedChildren.filter(child => !this._isMeaninglessSpan(child));
      if (pruned.length !== orderedChildren.length) {
        orderedChildren = pruned;
      }
    }

    // Finalize VNode: handle text collapse, component identity, etc.
    this._finalizeElementVNode(vnode, orderedChildren, hasDataTextProcessed, data, options);
    if (vnode.stype === 'inline-text') {
      logger.debug(LogCategory.VNODE, 'inline-text vnode', this.serializeVNodeTree(vnode, 0, 4));
    }

    return vnode;
  }


  /**
   * Apply template attributes (props) and data bindings (model) to VNode
   * 
   * ElementTemplate의 attributes는 props입니다:
   * - element('div', { className: 'test' }, [])에서 { className: 'test' }가 props
   * - template.attributes는 템플릿 정의 시점의 props
   * - data는 런타임 model 데이터
   */
  private _applyElementAttributes(vnode: VNode, template: ElementTemplate, data: ModelData): void {
    // Apply template attributes (props) first
    // template.attributes: props at template definition time
    // data: runtime model data (used for dynamic attribute resolution)
    this._setAttributes(vnode, template.attributes, data);
  }

  /**
   * Process element children and return ordered children array
   */
  private _processElementChildren(
    template: ElementTemplate,
    data: ModelData,
    vnode: VNode,
    buildOptions: VNodeBuildOptions
  ): { orderedChildren: VNode[]; hasDataTextProcessed: { value: boolean } } {
    const orderedChildren: VNode[] = [];
    let currentTextParts: string[] = [];

    // Track if data('text') was processed directly in this element's children
    // This is used to prevent collapsing text children when data('text') was processed
    const hasDataTextProcessed = { value: false };

    // Helper function to flush current text parts as a text VNode
    const flushTextParts = () => {
      if (isNonEmptyArray(currentTextParts)) {
        const textContent = currentTextParts.join('');
        currentTextParts = [];
        if (textContent.length === 0) {
          return;
        }
        const textVNode = createTextVNode(textContent);
        orderedChildren.push(textVNode);
      }
    };

    const injectedUsedRef = { value: false };
    const childrenArray = Array.isArray(template?.children) ? template.children : [];

    try {
      childrenArray.forEach((child) => {
        this._processChild(child, data, vnode, orderedChildren, currentTextParts, flushTextParts, injectedUsedRef, buildOptions, hasDataTextProcessed);
      });
    } catch (err) {
      throw err;
    }

    // Flush any remaining text parts
    flushTextParts();

    return { orderedChildren, hasDataTextProcessed };
  }

  /**
   * Detect span wrappers that carry no data/children/text, so they can be pruned before reconciliation.
   */
  private _isMeaninglessSpan(vnode: VNode | string | number | undefined | null): boolean {
    if (!vnode || typeof vnode !== 'object') {
      return false;
    }
    if (vnode.tag !== 'span') {
      return false;
    }
    if (vnode.sid || vnode.attrs?.[DOMAttribute.DECORATOR_SID]) {
      return false;
    }
    const hasAttrs = vnode.attrs && Object.keys(vnode.attrs).length > 0;
    const hasStyles = vnode.style && Object.keys(vnode.style).length > 0;
    if (hasAttrs || hasStyles) {
      return false;
    }
    const hasChildren = Array.isArray(vnode.children) && vnode.children.length > 0;
    if (hasChildren) {
      return false;
    }
    if (vnode.text !== undefined && vnode.text !== null) {
      return String(vnode.text).trim().length === 0;
    }
    return true;
  }

  /**
   * Finalize element VNode: handle text collapse, component identity, etc.
   */
  private _finalizeElementVNode(
    vnode: VNode,
    orderedChildren: VNode[],
    hasDataTextProcessed: { value: boolean },
    data: ModelData,
    options?: { injectChild?: VNode; useDataAsSlot?: boolean; decorators?: Decorator[]; sid?: string }
  ): void {
    // Root auto-text mapping only when no children to avoid conflict
    if (orderedChildren.length === 0 && isString(data?.content)) {
      vnode.text = data.content;
    }

    // IMPORTANT: Clear vnode.children before setting orderedChildren to avoid duplication
    // This ensures that slot children added via _renderSlotGetChildren don't get duplicated
    // when _buildElement sets vnode.children = [...orderedChildren]
    vnode.children = [];

    // Check if data('text') was processed directly in this element's children
    // When data('text') is processed, it generates VNodes that should always be in children,
    // never collapsed to parent.text, because decorators may split the text into multiple VNodes
    // IMPORTANT: When checking for collapse, we should exclude decorators from the count
    // because decorators are added as siblings (to parent's children), not to this node's children
    const shouldCollapse = shouldCollapseTextChild(orderedChildren, hasDataTextProcessed);
    applyTextCollapse(vnode, orderedChildren, shouldCollapse);

    // Set sid at top level for component-generated VNodes (those with tag and stype)
    // These are NOT added to attrs as data-bc-* (those are added by Reconciler to DOM)
    // props, model, decorators, stype are already set by attachComponentInfo
    // IMPORTANT: sid comes from model data, but if missing and stype exists, auto-generate it
    if (vnode.tag && vnode.stype) {
      applyComponentIdentity(vnode, data, options, this.currentBuildOptions, this.componentManager);
    }
  }


  /**
   * ComponentTemplate 자식 요소 처리 (테스트 가능한 독립 함수)
   * 
   * @param child - ComponentTemplate 자식
   * @param data - 부모의 모델 데이터
   * @param buildOptions - 빌드 옵션
   * @returns VNode 또는 null
   */
  private _processComponentChild(
    child: ComponentTemplate,
    data: ModelData,
    buildOptions: { injectChild?: VNode; useDataAsSlot?: boolean; decorators?: Decorator[]; sid?: string }
  ): VNode | null {
    // Pass ComponentTemplate's props as data (item component uses data('text'))
    const childProps = child.props || {};
    const childData = { ...data, ...childProps };
    return this._buildComponent(child, childData, buildOptions);
  }

  /**
   * Processes a single child element in the template
   * 
   * @param child - The child element to process
   * @param data - Model data for data binding
   * @param orderedChildren - Array to add processed VNodes to
   * @param currentTextParts - Array to add text parts to
   * @param flushTextParts - Function to flush text parts as VNode
   * @param options - Optional configuration
   * @param injectedUsed - Whether injection has been used
   */
  private _processChild(
    child: any,
    data: ModelData,
    vnode: VNode,
    orderedChildren: VNode[],
    currentTextParts: string[],
    flushTextParts: () => void,
    injectedUsedRef: { value: boolean },
    options?: { injectChild?: VNode; useDataAsSlot?: boolean; decorators?: Decorator[]; sid?: string },
    hasDataTextProcessed?: { value: boolean }
  ): void {
    // Ignore null or undefined
    if (isNullOrUndefined(child)) {
      return;
    }

    // Merge build options
    const buildOptions = this._mergeBuildOptions(options);

    // Handle function child - execute with data and process result
    if (isFunction(child)) {
      this._processFunctionChild(child, data, orderedChildren, currentTextParts, flushTextParts, buildOptions);
      return;
    }
    
    // Handle VNode (already built)
    if (isVNode(child) && !('type' in child)) {
      orderedChildren.push(child as VNode);
      return;
    }
    
    // Handle string/number (text content)
    if (isStringOrNumber(child)) {
      currentTextParts.push(String(child));
      return;
    }
    
    // Handle ComponentTemplate
    if (isComponentTemplate(child)) {
      const componentVNode = this._processComponentChild(child as ComponentTemplate, data, buildOptions);
      if (componentVNode) {
        // Process block/layer decorators for this component child
        // IMPORTANT: Build decorators fresh from model and decorators (unidirectional)
        const decorators = buildOptions.decorators || [];
        const childSid = componentVNode.sid || extractNodeId(componentVNode, data);
        if (childSid && decorators.length > 0) {
          const childDecorators = this.decoratorProcessor.findDecoratorsForNode(String(childSid), decorators);
          const categorized = this.decoratorProcessor.categorizeDecorators(childDecorators);
          const blockLayerDecorators = [...categorized.block, ...categorized.layer];
          
          if (isNonEmptyArray(blockLayerDecorators)) {
            // Build NEW decorator nodes (not reused)
            const decoratorNodes = this.decoratorProcessor.buildDecoratorVNodes(
              blockLayerDecorators,
              (template, data, options) => this._buildElement(template, data, options)
            );
            
            // Separate before and after decorators
            const beforeDecorators: VNode[] = [];
            const afterDecorators: VNode[] = [];
            
            for (const decoratorNode of decoratorNodes) {
              const position = decoratorNode.attrs?.[DOMAttribute.DECORATOR_POSITION] || 'after';
              if (position === 'before') {
                beforeDecorators.push(decoratorNode);
              } else {
                afterDecorators.push(decoratorNode);
              }
            }
            
            // Add in order: before decorators, child, after decorators
            flushTextParts();
            orderedChildren.push(...beforeDecorators);
            orderedChildren.push(componentVNode);
            orderedChildren.push(...afterDecorators);
          } else {
            // No block decorators, add child as-is
      this._flushAndAddVNode(flushTextParts, componentVNode, orderedChildren);
          }
        } else {
          // No sid or no decorators, add child as-is
          this._flushAndAddVNode(flushTextParts, componentVNode, orderedChildren);
        }
      }
      return;
    }
    
    // Handle ElementTemplate
    if (isObject(child) && 'type' in child && child.type === 'element') {
      this._processElementTemplateChild(
        child as ElementTemplate,
        data,
        orderedChildren,
        flushTextParts,
        buildOptions
      );
      return;
    }
    
    // Handle DataTemplate
    if (isDataTemplate(child)) {
      const shouldReturn = this._processDataTemplateChild(
        child,
        data,
        orderedChildren,
        currentTextParts,
        flushTextParts,
        buildOptions,
        options,
        injectedUsedRef,
        hasDataTextProcessed
      );
      // Return only if shouldReturn is true (injectChild processed case)
      // If false, normal processing complete, continue with next child
      if (shouldReturn) return;
      // If false, do not return here, continue
    }
    
    // Handle SlotTemplate
    if (isSlotTemplate(child)) {
      const slotChildren = this._renderSlotGetChildren(vnode, child, data);
      this._flushAndAddVNodes(flushTextParts, slotChildren, orderedChildren);
      return;
    }
    
    // Handle EachTemplate
    if (isEachTemplate(child)) {
      this._processEachTemplateChild(child, data, orderedChildren, flushTextParts, buildOptions);
      return;
    }
    
    // Handle ConditionalTemplate
    if (isConditionalTemplate(child)) {
      this._processConditionalTemplateChild(child, data, orderedChildren, currentTextParts, flushTextParts, buildOptions);
      return;
    }
    
    // Handle PortalTemplate
    if (isPortalTemplate(child)) {
      const portalVNode = this._buildPortal(child, data);
      this._flushAndAddVNode(flushTextParts, portalVNode, orderedChildren);
      return;
    }
    
    // Ignore stray attribute-like objects accidentally placed in children
    if (isObject(child) && (child as any).type && !['element', 'data', 'slot', 'each', 'conditional', 'component'].includes((child as any).type)) {
      return;
    }
  }

  /**
   * Process function child - execute with data and process result
   * 
   * @param child - Function to execute
   * @param data - Model data
   * @param orderedChildren - Array to add child VNodes to
   * @param currentTextParts - Array to add text parts to
   * @param flushTextParts - Function to flush text parts
   * @param buildOptions - Build options
   */
  private _processFunctionChild(
    child: Function,
    data: ModelData,
    orderedChildren: VNode[],
    currentTextParts: string[],
    flushTextParts: () => void,
    buildOptions: VNodeBuildOptions
  ): void {
    const result = child(data);
    if (isStringOrNumber(result)) {
      currentTextParts.push(String(result));
    } else if (Array.isArray(result)) {
      // Handle array result - process each item
      for (const item of result) {
        if (isObject(item) && 'type' in item) {
          this._processTemplateResult(item, data, orderedChildren, currentTextParts, flushTextParts, buildOptions);
        } else if (isNullOrUndefined(item)) {
          // Skip null/undefined items
          continue;
        }
      }
    } else if (isObject(result) && 'type' in result) {
      // Handle DataTemplate separately (doesn't need flushTextParts, adds to currentTextParts)
      if (isDataTemplate(result)) {
        const value = (result as DataTemplate).getter ? (result as DataTemplate).getter?.(data) : getDataValue(data, (result as DataTemplate).path!);
        const resolved = isNullOrUndefined(value) ? (result as DataTemplate).defaultValue : value;
        if (isString(resolved)) {
          currentTextParts.push(resolved);
        } else if (isNullOrUndefined(resolved)) {
        } else {
          currentTextParts.push(String(resolved));
        }
      } else {
        // Recursively process the result as a template (ElementTemplate, ComponentTemplate, PortalTemplate)
        this._processTemplateResult(result, data, orderedChildren, currentTextParts, flushTextParts, buildOptions);
      }
    }
  }

  /**
   * Process EachTemplate child - iterate data array and render each item
   * 
   * @param child - EachTemplate to process
   * @param data - Model data
   * @param orderedChildren - Array to add child VNodes to
   * @param flushTextParts - Function to flush text parts
   * @param buildOptions - Build options
   */
  private _processEachTemplateChild(
    child: EachTemplate,
    data: ModelData,
    orderedChildren: VNode[],
    flushTextParts: () => void,
    buildOptions: VNodeBuildOptions
  ): void {
    // Iterate data[child.name] array and render each item
    flushTextParts(); // Flush any accumulated text before each
    const items: any[] = Array.isArray((data as any)[child.name]) ? (data as any)[child.name] : [];
    const keyFn = child.key;
    const decorators = buildOptions.decorators || [];
    
    items.forEach((item, index) => {
      const childTemplate = child.render(item, index);
      const childSid = item?.sid || (item as any)?.id;
      
      // Find decorators for this child (if sid exists)
      let childDecorators: Decorator[] = [];
      if (childSid && decorators.length > 0) {
        childDecorators = this.decoratorProcessor.findDecoratorsForNode(String(childSid), decorators);
      }
      
      // Build child VNode with decorators passed in options
      // Note: Inline decorators are handled inside _buildElement via _processDataTemplateChild
      // Block/layer decorators are handled here after building
      const childVNode = this._buildElement(childTemplate, item, {
        ...buildOptions,
        sid: childSid,
        decorators: childDecorators // Pass child-specific decorators
      });
      
      // sid should be set at VNode top level (data-bc-sid is added by Reconciler)
      // Set key if key function is provided (for efficient reconciliation)
      if (keyFn && isFunction(keyFn)) {
        childVNode.key = String(keyFn(item, index));
      }
      
      // Process block/layer decorators for this child
      // IMPORTANT: Build decorators fresh from model and decorators (unidirectional)
      if (childSid && childDecorators.length > 0) {
        const categorized = this.decoratorProcessor.categorizeDecorators(childDecorators);
        const blockLayerDecorators = [...categorized.block, ...categorized.layer];
        
        if (isNonEmptyArray(blockLayerDecorators)) {
          // Build NEW decorator nodes (not reused)
          const decoratorNodes = this.decoratorProcessor.buildDecoratorVNodes(
            blockLayerDecorators,
            (template, data, options) => this._buildElement(template, data, options)
          );
          
          // Separate before and after decorators
          const beforeDecorators: VNode[] = [];
          const afterDecorators: VNode[] = [];
          
          for (const decoratorNode of decoratorNodes) {
            const position = decoratorNode.attrs?.['data-decorator-position'] || 'after';
            if (position === 'before') {
              beforeDecorators.push(decoratorNode);
            } else {
              afterDecorators.push(decoratorNode);
            }
          }
          
          // Add in order: before decorators, child, after decorators
          orderedChildren.push(...beforeDecorators);
      orderedChildren.push(childVNode);
          orderedChildren.push(...afterDecorators);
        } else {
          // No block decorators, add child as-is
          orderedChildren.push(childVNode);
        }
      } else {
        // No sid or no decorators, add child as-is
        orderedChildren.push(childVNode);
      }
    });
  }

  /**
   * Process ConditionalTemplate child - evaluate condition and render chosen template
   * 
   * @param child - ConditionalTemplate to process
   * @param data - Model data
   * @param orderedChildren - Array to add child VNodes to
   * @param ata - Array to add text parts to
   * @param flushTextParts - Function to flush text parts
   * @param buildOptions - Build options
   */
  private _processConditionalTemplateChild(
    child: ConditionalTemplate,
    data: ModelData,
    orderedChildren: VNode[],
    currentTextParts: string[],
    flushTextParts: () => void,
    buildOptions: VNodeBuildOptions
  ): void {
    // Evaluate condition at build time and render the chosen template
    const condition = isFunction(child.condition) ? !!child.condition(data) : !!child.condition;
    const chosenTemplate = condition ? child.template : child.elseTemplate;

    if (chosenTemplate) {
      // Recursively build the chosen template as a regular child
      this._processTemplateResult(chosenTemplate, data, orderedChildren, currentTextParts, flushTextParts, buildOptions);
    }
  }

  /**
   * Process DataTemplate child - resolve value and handle marks/decorators
   * 
   * @param child - DataTemplate to process
   * @param data - Model data
   * @param orderedChildren - Array to add child VNodes to
   * @param currentTextParts - Array to add text parts to
   * @param flushTextParts - Function to flush text parts
   * @param buildOptions - Build options
   * @param options - Original options (for injectChild)
   * @param injectedUsedRef - Reference to track if child was injected
   * @param hasDataTextProcessed - Reference to track if data('text') was processed
   * @returns true if should return early (injectChild case)
   */
  private _processDataTemplateChild(
    child: DataTemplate,
    data: ModelData,
    orderedChildren: VNode[],
    currentTextParts: string[],
    flushTextParts: () => void,
    buildOptions: VNodeBuildOptions,
    options?: { injectChild?: VNode; useDataAsSlot?: boolean; decorators?: Decorator[]; sid?: string },
    injectedUsedRef?: { value: boolean },
    hasDataTextProcessed?: { value: boolean }
  ): boolean {
    // When building a mark wrapper in nested context, treat the first data('text') like an implicit slot
    if (child.path === 'text' && options?.useDataAsSlot && options.injectChild && injectedUsedRef && !injectedUsedRef.value) {
      flushTextParts();
      orderedChildren.push(options.injectChild);
      injectedUsedRef.value = true;
      return true;
    }
    const value = child.getter ? child.getter(data) : getDataValue(data, child.path!);
    const resolved = isNullOrUndefined(value) ? (child as any).defaultValue : value;

    // Track if data('text') was processed directly in this element's children
    if (child.path === 'text' && hasDataTextProcessed) {
      hasDataTextProcessed.value = true;
    }

    if (isString(resolved)) {
      const marks = getMarks(data);
      const sid = buildOptions.sid || getSid(data);
      

      // Find inline decorators for this node
      let decorators = buildOptions.decorators || [];

      // Generate pattern decorators if pattern generator is available
      if (this.patternDecoratorGenerator && sid) {
        const patternDecorators = this.patternDecoratorGenerator.generateDecoratorsFromText(sid, resolved);
        decorators = [...decorators, ...patternDecorators];
      }

      // Generate custom decorators if custom generator manager is available
      if (this.customDecoratorGeneratorManager && sid) {
        const customDecorators = this.customDecoratorGeneratorManager.generateDecorators(data, resolved);
        decorators = [...decorators, ...customDecorators];
      }

      const inlineDecorators = this.decoratorProcessor.findInlineDecorators(sid, decorators);

      if ((marks && marks.length > 0) || inlineDecorators.length > 0) {
        flushTextParts();
        // Convert marks to format expected by splitTextByMarks (TextMark[])
        // IMPORTANT: TextMark now uses 'stype' to match IMark interface
        // Marks without range remain undefined (handled as globalMarks in splitTextByMarks)
        const textMarks = marks ? marks.map(m => ({
          stype: (m as any).stype, // IMark uses 'stype'
          range: m.range || undefined, // Keep as undefined if no range
          attrs: (m as any).attrs || (m as any).attributes
        })) : undefined;
        // Process both marks and inline decorators together
        const nodes = this._buildMarkedRunsWithDecorators(resolved, textMarks as any, inlineDecorators, data);
        this._flushAndAddVNodes(flushTextParts, nodes, orderedChildren);
      } else {
        flushTextParts();
        orderedChildren.push(createSpanWrapper([createTextVNode(resolved)]));
      }
    } else if (isNullOrUndefined(resolved)) {
    } else {
      currentTextParts.push(String(resolved));
    }
    return false;
  }

  /**
   * Builds a VNode for portal rendering
   * 
   * Portals allow rendering content to a different DOM target than the parent.
   * This method creates a portal VNode that contains the template to be rendered
   * in the target element.
   * 
   * @param template - The PortalTemplate defining the portal
   * @param data - Model data for template evaluation
   * @returns VNode representing the portal
   */
  private _buildPortal(template: PortalTemplate, data: ModelData): VNode | null {
    let target = isFunction((template as any).target) ? (template as any).target(data) : (template as any).target;


    // Resolve selector strings to actual HTMLElements
    if (isString(target)) {
      const sel = target;
      target = sel === 'body' ? document.body : (document.querySelector(sel) as HTMLElement | null);
    }

    // Validate target
    if (!target || !(target instanceof HTMLElement)) {
      const providedTarget = (template as any)?.target;
      if (isString(providedTarget)) {
        console.warn('Portal target is not a valid DOM element', { rawTarget: providedTarget, target, template });
      } else {
        console.warn('Portal missing target or template', { target: providedTarget ?? target, template });
      }
      return null;
    }

    // Generate consistent portalId - prioritize provided portalId for multiple portals to same target
    // Avoid JSON.stringify to prevent circular structure errors
    const portalId = template.portalId || 'portal-default';


    const vnode: VNode = {
      tag: VNodeTag.PORTAL,
      attrs: {
        target
      },
      portal: {
        target,
        template: template.template,
        portalId
      },
      children: []
    };

    // Build the portal content VNode
    if (template.template) {
      // Handle conditional template
      const tmpl = (template as any).template;
      if (tmpl && isConditionalTemplate(tmpl)) {
        const cond = isFunction(tmpl.condition) ?
          !!tmpl.condition(data || {}) : !!tmpl.condition;
        const chosen = cond ? tmpl.template : tmpl.elseTemplate;
        if (chosen) {
          const contentVNode = this._buildElement(chosen as ElementTemplate, data);
          vnode.children = [contentVNode];
        }
      } else if (tmpl) {
        const contentVNode = this._buildElement(tmpl as ElementTemplate, data);
        vnode.children = [contentVNode];
      }
    }

    return vnode;
  }

  /**
   * Applies attributes to a VNode with data binding support
   * 
   * This method processes template attributes and applies them to the VNode,
   * handling various types of attribute values:
   * 
   * - Static values: Applied directly
   * - Function values: Called with data to get resolved value
   * - DataTemplate objects: Resolved using data binding
   * - Event handlers: Preserved as functions (on* attributes)
   * - Style objects: Processed with nested data binding
   * - className: Special handling for CSS class tokens
   * 
   * @param vnode - The VNode to apply attributes to
   * @param attributes - Template attributes to process
   * @param data - Model data for data binding
   */
  private _setAttributes(vnode: VNode, attributes: Record<string, any>, data: ModelData): void {
    if (!attributes) return;
    if (!vnode.attrs) vnode.attrs = {};

    Object.entries(attributes).forEach(([key, value]) => {
      if (isNullOrUndefined(value)) return;

      // Preserve event handlers as-is
      if (isEventHandler(key, value)) {
        vnode.attrs![key] = value;
        return;
      }

      const resolvedValue = resolveAttributeValue(vnode, key, value, data);

      if (key === 'style' && isStyleObject(resolvedValue)) {
        const styleObj = resolveStyleObject(resolvedValue, data);
        if (Object.keys(styleObj).length > 0) {
          vnode.style = { ...vnode.style, ...styleObj };
        }
        delete vnode.attrs!['style'];
        return;
      }

      if (key === 'className') {
        const finalClass = resolveClassName(resolvedValue, data);
        if (finalClass) {
          vnode.attrs![key] = finalClass;
        }
        return;
      }

      if (isEventHandler(key, resolvedValue)) {
        vnode.attrs![key] = resolvedValue;
        return;
      }

      if (isDefined(resolvedValue)) {
        vnode.attrs![key] = isBoolean(resolvedValue) ? resolvedValue : String(resolvedValue);
      }
    });
  }


  /**
   * Renders slot content and returns children array instead of modifying vnode.children directly
   * This allows slot children to be properly integrated into orderedChildren
   * 
   * @param vnode - The VNode (for compatibility, but children are not modified here)
   * @param slot - The SlotTemplate defining the slot
   * @param data - Model data containing the slot content
   * @returns Array of VNodes representing slot content
   */
  private _renderSlotGetChildren(vnode: VNode, slot: SlotTemplate, data: ModelData): VNode[] {
    // Named slots: access data[slot.name] directly
    // ex) slot('content') -> data.content, slot('header') -> data.header
    const items: any[] | undefined = data?.[slot.name];
    let list: any[];

    if (Array.isArray(items)) {
      list = items;
    } else if (isDefined(items)) {
      // Handle non-array values (strings, numbers, objects) as single items
      list = [items];
    } else {
      list = [];
    }

    const slotChildren: VNode[] = [];

    // debug: slot render
    for (let index = 0; index < list.length; index++) {
      const child = list[index];

      // Handle primitive values (strings, numbers) as text content
      if (isStringOrNumber(child)) {
        // Create text VNode
        slotChildren.push(createTextVNode(child));
        continue;
      }

      // Determine childType using child.stype or child.type
      // Use actual stype/type of child, not hardcoded values like 'item'
      const childType = child.stype || child.type;

      if (!childType) {
        // Skip if no childType
        continue;
      }

      // Create VNode using childType (using child.stype or child.type)
      // Directly call _buildExternalComponent or _buildContextComponentFromFunction to avoid build() recursive call
      const component = this.registry.getComponent?.(childType);
      if (!component) {
        // Skip if no component
        continue;
      }
      
      const childBuildOptions = {
        sid: child.sid,
        decorators: this.currentBuildOptions?.decorators
      };
      
      let childVNode: VNode;
      if (component.managesDOM === true) {
        // External component: build directly without recursive call
        childVNode = this._buildExternalComponent(childType, component, child, childBuildOptions);
      } else {
        // Context component: build directly without recursive call
        childVNode = this._buildContextComponentFromFunction(childType, component, child, childBuildOptions);
      }

      // Ensure child has sid and stype at top level (for component-generated VNodes with tag)
      // IMPORTANT: sid comes from model, but if missing and stype exists, auto-generate it
      if (childVNode.tag && childVNode.stype) {
        // sid comes directly from child model - use it as-is
        if (!childVNode.sid && child.sid) {
          childVNode.sid = String(child.sid);
        }
        // If no sid from model but stype exists, auto-generate it
        if (!childVNode.sid && childVNode.stype && this.componentManager) {
          if (typeof this.componentManager.generateComponentId === 'function') {
            const generatedSid = this.componentManager.generateComponentId(childVNode);
            if (generatedSid) {
              markAutoGeneratedSid(childVNode, generatedSid);
            }
          }
        }

        if (!childVNode.stype && child.stype) {
          childVNode.stype = child.stype;
        }
      }

      // Process block/layer decorators for this slot child
      // IMPORTANT: Build decorators fresh from model and decorators (unidirectional)
      const decorators = childBuildOptions.decorators || [];
      const childSid = childVNode.sid || child.sid;
      if (childSid && decorators.length > 0) {
        const childDecorators = this.decoratorProcessor.findDecoratorsForNode(String(childSid), decorators);
        const categorized = this.decoratorProcessor.categorizeDecorators(childDecorators);
        const blockLayerDecorators = [...categorized.block, ...categorized.layer];
        
        if (isNonEmptyArray(blockLayerDecorators)) {
          // Build NEW decorator nodes (not reused)
          const decoratorNodes = this.decoratorProcessor.buildDecoratorVNodes(
            blockLayerDecorators,
            (template, data, options) => this._buildElement(template, data, options)
          );
          
          // Separate before and after decorators
          const beforeDecorators: VNode[] = [];
          const afterDecorators: VNode[] = [];
          
          for (const decoratorNode of decoratorNodes) {
            const position = decoratorNode.attrs?.['data-decorator-position'] || 'after';
            if (position === 'before') {
              beforeDecorators.push(decoratorNode);
            } else {
              afterDecorators.push(decoratorNode);
            }
          }
          
          // Add in order: before decorators, child, after decorators
          slotChildren.push(...beforeDecorators);
          slotChildren.push(childVNode);
          slotChildren.push(...afterDecorators);
        } else {
          // No block decorators, add child as-is
      slotChildren.push(childVNode);
        }
      } else {
        // No sid or no decorators, add child as-is
        slotChildren.push(childVNode);
      }
    }

    return slotChildren;
  }

  /**
   * Builds a VNode from a ComponentTemplate
   * 
   * This method handles various types of components:
   * 
   * - Registered renderers: Components registered via define()
   * - External components: Components that manage their own DOM
   * - Context components: Components with state management
   * 
   * The method resolves props, handles children, and creates appropriate VNodes
   * for each component type, ensuring proper data binding and lifecycle management.
   * 
   * @param template - The ComponentTemplate to build
   * @param data - Model data for data binding
   * @param options - Optional configuration for special cases
   * @returns VNode representing the component, or null if component not found
   */
  private _buildComponent(template: ComponentTemplate, data: ModelData, options?: VNodeBuildOptions & { injectChild?: VNode; useDataAsSlot?: boolean }): VNode | null {
    // Use current build options or merge with provided options
    const buildOptions = this._mergeBuildOptions(options, getSid(data));

    // Get registered component (check once)
    // Everything defined with define() can only be a component, so only use getComponent()
    // 
    // Note: template.component check is unnecessary
    // - ComponentTemplate created with component() function has no component property
    // - Templates created with define() are handled by build() function, so they won't reach _buildComponent()
    const component = this.registry.getComponent(template.name);
    if (!component) {
      return null;
    }

    // Try building as registered component first
    const result = this._buildRegisteredComponent(component, template, data, buildOptions);
    if (result) return result;

    // Resolve props and key
    const { props, key } = resolveComponentPropsAndKey(template, data);

    // Components registered via registerContextComponent (managesDOM === false)
    // Context components immediately build element templates so decorators/marks are reflected inside
    if (component.managesDOM === false && isFunction(component.template)) {
      return this._buildContextComponent(template, component, props, data, buildOptions);
    }

    // DOM-managing components (managesDOM === true)
    return this._buildDOMManagingComponent(template, component, props, data, buildOptions);
  }


  /**
   * Build context component (managesDOM === false)
   * Context components immediately build element templates so decorators/marks are reflected inside
   */
  private _buildContextComponent(
    template: ComponentTemplate,
    component: any,
    props: Record<string, any>,
    data: ModelData,
    buildOptions: VNodeBuildOptions
  ): VNode {
    const resolvedProps = sanitizePropsUtil(props);
    const mergedData = { ...data, ...resolvedProps } as any;
    const elementTemplate = component.template(resolvedProps, mergedData, this._makeContext(`${template.name}-${mergedData?.sid ?? 'noid'}`, {}, resolvedProps, mergedData, {}));
    const vnode = this._buildElement(elementTemplate as ElementTemplate, mergedData, buildOptions);

    // Assign component identity (so it can be recognized as a component in reconcile)
    vnode.attrs = vnode.attrs || {} as any;
    assignComponentIdentityAttrs(vnode.attrs as Record<string, any>, template.name, mergedData, undefined, (id) => this.ensureUniqueId(id));

    attachComponentInfoWithSeparatedData(
      vnode,
      template.name,
      resolvedProps,
      mergedData,
      resolveDecoratorsFromBuildOptions(buildOptions)
    );

    return vnode;
  }

  /**
   * Build DOM-managing component (managesDOM === true)
   */
  private _buildDOMManagingComponent(
    template: ComponentTemplate,
    component: any,
    props: Record<string, any>,
    data: ModelData,
    buildOptions: VNodeBuildOptions
  ): VNode {
    // Render children (when managesDOM is true)
    const children = this._renderComponentChildren(template, data, props, buildOptions);

    const { sanitizedProps, modelData, decorators } = prepareComponentWrapperData(
      data,
      props,
      buildOptions
    );
    const wrapperAttrs = createComponentWrapperAttrs(template.name, data, (id) => this.ensureUniqueId(id));

    const vnode: VNode = {
      tag: 'div', // wrap component with div
      attrs: wrapperAttrs,
      stype: template.name,
      props: { ...sanitizedProps, children },  // Use sanitized props
      // Decorators are already processed in VNodeBuilder and reflected in VNode tree, so don't store
      children: component.managesDOM ? undefined : children
    };

    // Determine if this is an external component (managesDOM pattern)
    const hasManagesDOM = component.managesDOM === true;
    const isManagesDOMComponent = hasManagesDOM && isFunction(component.mount);

    vnode.isExternal = isManagesDOMComponent || isExternalComponent(component);

    return vnode;
  }


  private _resolveDecoratorsFromOptions(override?: Decorator[] | null): Decorator[] | undefined {
    if (override !== undefined && override !== null) {
      return override;
    }
    return this.currentBuildOptions?.decorators;
  }

  /**
   * Flush text parts and add VNode to ordered children
   * Helper function to reduce duplication
   * 
   * @param flushTextParts - Function to flush text parts
   * @param vnode - VNode to add (can be null)
   * @param orderedChildren - Array to add VNode to
   */
  private _flushAndAddVNode(
    flushTextParts: () => void,
    vnode: VNode | null,
    orderedChildren: VNode[]
  ): void {
    if (vnode) {
      flushTextParts();
      orderedChildren.push(vnode);
    }
  }

  /**
   * Flush text parts and add Element VNode to ordered children
   * Helper function to reduce duplication (ElementTemplate always returns VNode, not null)
   * 
   * @param flushTextParts - Function to flush text parts
   * @param elementTemplate - ElementTemplate to build
   * @param data - Model data
   * @param buildOptions - Build options
   * @param orderedChildren - Array to add VNode to
   */
  private _flushAndAddElement(
    flushTextParts: () => void,
    elementTemplate: ElementTemplate,
    data: ModelData,
    buildOptions: VNodeBuildOptions,
    orderedChildren: VNode[]
  ): void {
    flushTextParts();
    orderedChildren.push(this._buildElement(elementTemplate, data, buildOptions));
  }

  /**
   * Flush text parts and add multiple VNodes to ordered children
   * Helper function to reduce duplication
   * 
   * @param flushTextParts - Function to flush text parts
   * @param vnodes - Array of VNodes to add
   * @param orderedChildren - Array to add VNodes to
   */
  private _flushAndAddVNodes(
    flushTextParts: () => void,
    vnodes: VNode[],
    orderedChildren: VNode[]
  ): void {
    if (vnodes.length > 0) {
      flushTextParts();
      for (const vnode of vnodes) {
        orderedChildren.push(vnode);
      }
    }
  }

  /**
   * Add VNode to array if not null (without flushing text parts)
   * Helper function for contexts where flushTextParts is not needed
   * 
   * @param vnode - VNode to add (can be null)
   * @param targetArray - Array to add VNode to
   */
  private _addVNodeIfNotNull(vnode: VNode | null, targetArray: VNode[]): void {
    if (vnode) {
      targetArray.push(vnode);
    }
  }

  /**
   * Process template result and add to ordered children
   * Handles ElementTemplate, ComponentTemplate, PortalTemplate
   * Helper function to reduce duplication
   * 
   * @param template - Template result (ElementTemplate, ComponentTemplate, or PortalTemplate)
   * @param data - Model data
   * @param orderedChildren - Array to add VNode to
   * @param currentTextParts - Array to add text parts to
   * @param flushTextParts - Function to flush text parts
   * @param buildOptions - Build options
   */
  private _processTemplateResult(
    template: any,
    data: ModelData,
    orderedChildren: VNode[],
    currentTextParts: string[],
    flushTextParts: () => void,
    buildOptions: VNodeBuildOptions
  ): void {
    if (template.type === 'element') {
      this._flushAndAddElement(flushTextParts, template as ElementTemplate, data, buildOptions, orderedChildren);
    } else if (isComponentTemplate(template)) {
      const componentVNode = this._buildComponent(template as ComponentTemplate, data, buildOptions);
      this._flushAndAddVNode(flushTextParts, componentVNode, orderedChildren);
    } else if (isPortalTemplate(template)) {
      const portalVNode = this._buildPortal(template, data);
      this._flushAndAddVNode(flushTextParts, portalVNode, orderedChildren);
    } else if (isStringOrNumber(template)) {
      currentTextParts.push(String(template));
    }
  }

  /**
   * Merge build options with current build options
   * Handles sid propagation logic: sid is only used if explicitly provided
   * 
   * @param options - Optional build options
   * @param defaultSid - Default sid to use if not provided in options
   * @returns Merged build options
   */
  private _mergeBuildOptions(
    options?: { decorators?: Decorator[]; sid?: string },
    defaultSid?: string
  ): VNodeBuildOptions {
    return {
      ...this.currentBuildOptions,
      ...options,
      decorators: this._resolveDecoratorsFromOptions(options?.decorators),
      // sid is only used if explicitly provided in options
      // If undefined is passed, keep as undefined (no parent sid inheritance)
      sid: options?.sid !== undefined 
        ? options.sid 
        : (this.currentBuildOptions?.sid !== undefined 
            ? this.currentBuildOptions.sid 
            : defaultSid)
    };
  }


  /**
   * Resolve child sid and build options for element template
   * 
   * @param child - ElementTemplate
   * @param data - Model data
   * @param buildOptions - Parent build options
   * @returns Object with childSid, childBuildOptions, and childData
   */
  private _resolveChildSidAndData(
    child: ElementTemplate,
    data: ModelData,
    buildOptions: VNodeBuildOptions
  ): { childSid?: string; childBuildOptions: VNodeBuildOptions; childData: ModelData } {
    // Extract child sid from attributes if available
    // Important: child elements only use sid if explicitly present
    // Do not automatically inherit parent's sid (each element must have unique sid)
    const childSid = child.attributes?.['data-bc-sid'] || child.attributes?.sid;
    
    // If childSid is absent, undefined (no parent sid inheritance)
    // When building child elements, explicitly pass sid (no sid if undefined)
    const childBuildOptions = {
      ...buildOptions,
      // If child has no explicit sid, propagate parent sid so inline decorators can be applied
      sid: childSid !== undefined 
        ? childSid 
        : (buildOptions.sid !== undefined ? buildOptions.sid : undefined)
    };
    
    // If childSid is absent, remove sid from data to prevent parent sid inheritance
    const childData = childSid !== undefined ? data : { ...data };
    
    return { childSid, childBuildOptions, childData };
  }

  /**
   * Process element template child
   * Handles both component tags and regular elements
   * 
   * @param child - ElementTemplate to process
   * @param data - Model data
   * @param orderedChildren - Array to add child VNodes to
   * @param flushTextParts - Function to flush text parts
   * @param buildOptions - Build options
   */
  private _processElementTemplateChild(
    child: ElementTemplate,
    data: ModelData,
    orderedChildren: VNode[],
    flushTextParts: () => void,
    buildOptions: VNodeBuildOptions
  ): void {
    const tag = child.tag;
    
    // Check if this is a component tag (strict: only registered components)
    if (isString(tag) && this.registry.getComponent(tag)) {
      // This is a component, build it as a component
      const componentTemplate = {
        type: 'component',
        name: tag,
        props: child.attributes || {}
      } as ComponentTemplate;
      const componentVNode = this._buildComponent(componentTemplate, data, buildOptions);
      if (componentVNode) {
        // Process block/layer decorators for this component child
        // IMPORTANT: Build decorators fresh from model and decorators (unidirectional)
        const decorators = buildOptions.decorators || [];
        const childSid = componentVNode.sid || extractNodeId(componentVNode, data);
        if (childSid && decorators.length > 0) {
          const childDecorators = this.decoratorProcessor.findDecoratorsForNode(String(childSid), decorators);
          const categorized = this.decoratorProcessor.categorizeDecorators(childDecorators);
          const blockLayerDecorators = [...categorized.block, ...categorized.layer];
          
          if (isNonEmptyArray(blockLayerDecorators)) {
            // Build NEW decorator nodes (not reused)
            const decoratorNodes = this.decoratorProcessor.buildDecoratorVNodes(
              blockLayerDecorators,
              (template, data, options) => this._buildElement(template, data, options)
            );
            
            // Separate before and after decorators
            const beforeDecorators: VNode[] = [];
            const afterDecorators: VNode[] = [];
            
            for (const decoratorNode of decoratorNodes) {
              const position = decoratorNode.attrs?.[DOMAttribute.DECORATOR_POSITION] || 'after';
              if (position === 'before') {
                beforeDecorators.push(decoratorNode);
              } else {
                afterDecorators.push(decoratorNode);
              }
            }
            
            // Add in order: before decorators, child, after decorators
            flushTextParts();
            orderedChildren.push(...beforeDecorators);
            orderedChildren.push(componentVNode);
            orderedChildren.push(...afterDecorators);
          } else {
            // No block decorators, add child as-is
      this._flushAndAddVNode(flushTextParts, componentVNode, orderedChildren);
          }
        } else {
          // No sid or no decorators, add child as-is
          this._flushAndAddVNode(flushTextParts, componentVNode, orderedChildren);
        }
      }
      return;
    }
    
    // Regular element processing
    const { childBuildOptions, childData } = this._resolveChildSidAndData(child, data, buildOptions);
    const elementVNode = this._buildElement(child, childData, childBuildOptions);
    
    // Process block/layer decorators for this element child
    // IMPORTANT: Build decorators fresh from model and decorators (unidirectional)
    const decorators = buildOptions.decorators || [];
    const childSid = elementVNode.sid || extractNodeId(elementVNode, childData);
    if (childSid && decorators.length > 0) {
      const childDecorators = this.decoratorProcessor.findDecoratorsForNode(String(childSid), decorators);
      const categorized = this.decoratorProcessor.categorizeDecorators(childDecorators);
      const blockLayerDecorators = [...categorized.block, ...categorized.layer];
      
      if (isNonEmptyArray(blockLayerDecorators)) {
        // Build NEW decorator nodes (not reused)
        const decoratorNodes = this.decoratorProcessor.buildDecoratorVNodes(
          blockLayerDecorators,
          (template, data, options) => this._buildElement(template, data, options)
        );
        
        // Separate before and after decorators
        const beforeDecorators: VNode[] = [];
        const afterDecorators: VNode[] = [];
        
        for (const decoratorNode of decoratorNodes) {
          const position = decoratorNode.attrs?.['data-decorator-position'] || 'after';
          if (position === 'before') {
            beforeDecorators.push(decoratorNode);
          } else {
            afterDecorators.push(decoratorNode);
          }
        }
        
        // Add in order: before decorators, child, after decorators
        flushTextParts();
        orderedChildren.push(...beforeDecorators);
        orderedChildren.push(elementVNode);
        orderedChildren.push(...afterDecorators);
      } else {
        // No block decorators, add child as-is
        flushTextParts();
        orderedChildren.push(elementVNode);
      }
    } else {
      // No sid or no decorators, add child as-is
      flushTextParts();
      orderedChildren.push(elementVNode);
    }
  }

  /**
   * Process inline decorators for a VNode (overlay, inside-start, inside-end)
   * Block decorators are handled at the parent level during children building
   */
  private _processInlineDecorators(vnode: VNode, decorators: Decorator[], sid: string, model: ModelData): void {
    if (!decorators || decorators.length === 0) {
      return;
    }

    // Separate by category
    const categorized = this.decoratorProcessor.categorizeDecorators(decorators);

    // Process inline decorators (overlay, inside-start, inside-end)
    const inlineDecorators = categorized.inline;
    if (inlineDecorators.length > 0) {
      // Inline decorators are handled by _buildMarkedRunsWithDecorators
      // This is called during text processing in _buildElement
      // So we don't need to do anything here for inline decorators
    }
  }

  /**
   * Build external component (managesDOM === true)
   */
  private _buildExternalComponent(
    nodeType: string,
    component: any,
    data: ModelData,
    options?: VNodeBuildOptions
  ): VNode {
    // External component: props are defined in template or absent
    // Do not extract props from data - props are determined at template definition time
    // sid comes directly from data, but if missing and stype exists, auto-generate it
    const modelSid = (data as any)?.sid || options?.sid;
    const nodeSid = modelSid ? String(modelSid) : undefined;
    // Decorators are already processed in VNodeBuilder and reflected in VNode tree, so don't store
    const vnode = createComponentVNode({
      sid: nodeSid,
      stype: nodeType,
      props: {},  // Empty object if not defined in template
      model: data,
      isExternal: true
    });
    
    // Auto-generate sid if stype exists but sid is missing
    if (vnode.stype && !vnode.sid && this.componentManager) {
      if (typeof this.componentManager.generateComponentId === 'function') {
        const generatedSid = this.componentManager.generateComponentId(vnode);
        if (generatedSid) {
          markAutoGeneratedSid(vnode, generatedSid);
          // Decorators are already processed in VNodeBuilder and reflected in VNode tree, so don't store
        }
      }
    }
    
    return vnode;
  }

  /**
   * Get component state and instance for stateful components
   */
  private _getComponentStateAndInstance(
    nodeType: string,
    props: Record<string, any>,
    model: ModelData
  ): { state: Record<string, any>; instance: any } {
    const componentId = `${nodeType}-${(model as any)?.sid ?? 'noid'}`;
    let componentState: Record<string, any> = {};
    let stateInstance: any = undefined;

    if (this.componentStateProvider) {
      try {
        const tempVNode = createComponentVNode({
          stype: nodeType,
          props
        });
        componentState = this.componentStateProvider.getComponentStateByVNode(tempVNode) || {};
        // Try to get state instance from ComponentManager
        if (this.componentManager) {
          const instance = this.componentManager.getInstance((model as any)?.sid || componentId);
          if (instance) {
            stateInstance = (instance as any).__stateInstance;
          }
        }
      } catch (error) {
        // If state provider fails, use empty state
        componentState = {};
      }
    }

    return { state: componentState, instance: stateInstance };
  }

  /**
   * Apply sid to VNode from model data
   */
  private _applySidToVNode(
    vnode: VNode,
    model: ModelData,
    options?: VNodeBuildOptions
  ): void {
    if (!vnode.tag || !vnode.stype) return;

    // Set sid from options or model
    const providedSid = (options && options.sid !== undefined) ? options.sid :
      (this.currentBuildOptions && this.currentBuildOptions.sid !== undefined) ? this.currentBuildOptions.sid :
        (model as any)?.sid;
    if (providedSid) {
      vnode.sid = String(providedSid);
    } else if (!vnode.sid && vnode.stype && this.componentManager) {
      // Auto-generate sid when stype exists but sid is missing
      if (typeof this.componentManager.generateComponentId === 'function') {
        const generatedSid = this.componentManager.generateComponentId(vnode);
        if (generatedSid) {
          markAutoGeneratedSid(vnode, generatedSid);
        }
      }
    }
  }

  /**
   * Build context component from function (managesDOM === false 또는 undefined)
   * component.template이 ContextualComponent 함수를 실행하여 ElementTemplate을 얻고 빌드
   */
  private _buildContextComponentFromFunction(
    nodeType: string,
    component: any,
    data: ModelData,
    options?: VNodeBuildOptions
  ): VNode {
    // component.template is a ContextualComponent function
    const componentFunction = component.template;
    if (!componentFunction || !isFunction(componentFunction)) {
      throw new Error(`Component '${nodeType}' must have a template function (ContextualComponent).`);
    }

    // Execute Component function: component(props, model, context)
    // props are defined in template or absent (not extracted from data)
    // model uses data as is
    const props = {};  // Empty object if not defined in template
    const model = data;

    // Get component state if available (for stateful components)
    const componentId = `${nodeType}-${(model as any)?.sid ?? 'noid'}`;
    const { state: componentState, instance: stateInstance } = this._getComponentStateAndInstance(nodeType, props, model);

    const minimalCtx = this._makeContext(componentId, componentState, props, model, {
      instance: stateInstance
    });

    try {
      const elementTemplate = componentFunction(props, model, minimalCtx) as ElementTemplate;

      // Component function must return an ElementTemplate
      if (!isObject(elementTemplate) || elementTemplate.type !== 'element') {
        throw new Error(`Component '${nodeType}' must return an ElementTemplate.`);
      }

      // elementTemplate.attributes are props
      // _buildElement: template.attributes are props, model is runtime data
      const vnode = this._buildElement(elementTemplate, model, options);
      // After attachComponentInfo, set sid and marks at top level
      this._applySidToVNode(vnode, model, options);
      // Element-based: no wrapper, do not assign component marker
      // Filter decorators for this specific node before attaching
      const nodeSid = vnode.sid || (model as any)?.sid;
      const filteredDecorators = nodeSid && options?.decorators 
        ? this.decoratorProcessor.findDecoratorsForNode(String(nodeSid), options.decorators)
        : [];
      attachComponentInfo(vnode, nodeType, model, filteredDecorators);
      return vnode;
    } catch (error) {
      // If execution fails, return component VNode for ComponentManager
      // Create ComponentTemplate: props are defined in template or absent
      // Do not extract props from data - props are determined at template definition time
      const componentTemplate = {
        type: 'component',
        name: nodeType,
        props: undefined  // undefined if not defined in template
      } as ComponentTemplate;
      const vnode = this._buildComponent(componentTemplate, data, options);
      if (vnode) {
        vnode.isExternal = false;
      }
      return vnode!;
    }
  }


  /**
   * Recursively process decorators for nested children
   * Block decorators are now handled at the parent level during children building
   * This method only processes inline decorators and recursively processes children
   * 
   * @param vnode - Current VNode
   * @param decorators - All decorators
   * @param sid - Current node's sid
   * @param model - Model data
   * @param parentVNode - Parent VNode (not used anymore, kept for compatibility)
   */
  private _processDecorators(vnode: VNode, decorators: Decorator[], sid: string, model: ModelData, parentVNode?: VNode): void {
    if (!decorators || decorators.length === 0) {
      return;
    }
    const nodeDecorators = this.decoratorProcessor.findDecoratorsForNode(sid, decorators);
    if (nodeDecorators.length === 0) {
      return;
    }

    // Process inline decorators
    this._processInlineDecorators(vnode, nodeDecorators, sid, model);

    // Block decorators are now handled at the parent level during children building
    // So we only need to recursively process children here

    // Recursively process children (but skip decorator nodes themselves to avoid infinite recursion)
    // Only process component VNodes (those with stype), not mark VNodes or other non-component nodes
    if (vnode.children && Array.isArray(vnode.children)) {
      for (const child of vnode.children) {
        if (isVNode(child)) {
          const childVNode = child as VNode;
          // Skip decorator nodes themselves
          if (childVNode.attrs?.[DOMAttribute.DECORATOR_SID]) {
            continue;
          }
          // Only process component VNodes (those with stype), not mark VNodes
          // Mark VNodes don't have stype, so they should not receive block/layer decorators
          if (!childVNode.stype) {
            continue;
          }
          const childSid = childVNode.attrs?.['data-bc-sid'] ||
            extractNodeId(childVNode, model);
          if (childSid) {
            // Pass current vnode as parent for child
            this._processDecorators(childVNode, decorators, childSid, model, vnode);
          }
        }
      }
    }
  }




  /**
   * Builds VNodes for text runs with both marks and decorators
   */
  private _buildMarkedRunsWithDecorators(
    text: string,
    marks: Array<{ type: string; range?: [number, number]; attrs?: Record<string, any> }> | undefined,
    inlineDecorators: Decorator[],
    model: ModelData
  ): VNode[] {
    const currentSid = this.currentBuildOptions?.sid ?? getSid(model);

    const markRuns = marks && marks.length > 0
      ? splitTextByMarks(text, marks as any)
      : [{ start: 0, end: text.length, text, classes: [], types: [] } as TextRun];

    const nodes: VNode[] = [];

    for (const markRun of markRuns) {
      // Convert decorator ranges from full text to markRun-relative
      const markRunRelativeDecorators = this._convertDecoratorRangesToMarkRunRelative(inlineDecorators, markRun);

      const decoratorRuns = this.decoratorProcessor.splitTextByDecorators(markRun.text, markRunRelativeDecorators);

      const selCtx = this.currentBuildOptions?.selectionContext;
      for (const decoratorRun of decoratorRuns) {
        if (process.env.NODE_ENV === 'test' && currentSid === 'text-1') {
          // eslint-disable-next-line no-console
          console.log('[DEBUG decoratorRun]', {
            markRunText: markRun.text,
            decoratorRunText: decoratorRun.text,
            decoratorRunStart: decoratorRun.start,
            decoratorRunEnd: decoratorRun.end,
            decoratorIds: (decoratorRun.decorators || (decoratorRun.decorator ? [decoratorRun.decorator] : []))
              .map((d: any) => d.sid)
          });
        }
        if (!decoratorRun.text || decoratorRun.text.length === 0) {
          continue;
        }
        let inner: VNode;

        if (markRun.types && markRun.types.length > 0) {
          const modifiedMarkRun: TextRun = {
            ...markRun,
            text: decoratorRun.text,
            start: decoratorRun.start,
            end: decoratorRun.end
          };
          inner = this._buildMarkedRunVNode(modifiedMarkRun, model);
        } else {
          // Render plain text as <span>, put text as text VNode in children
          inner = createSpanWrapper([
            createTextVNode(decoratorRun.text)
          ]);
        }
        // Selection Anchoring: determine inclusion based on absolute offset calculation (markRun.start + decoratorRun.start)
        if (selCtx && currentSid && selCtx.sid === currentSid) {
          const absStart = (markRun.start ?? 0) + (decoratorRun.start ?? 0);
          const absEnd = (markRun.start ?? 0) + (decoratorRun.end ?? decoratorRun.start ?? 0);
          if (selCtx.modelOffset >= absStart && selCtx.modelOffset < absEnd) {
            // NOTE: selection anchoring meta was unused downstream; keep node creation unchanged
          }
        }

        // Process multiple decorators (before/after, etc.)
        this._processDecoratorRuns(decoratorRun, inner, nodes, markRun);
      }
    }

    const hasContent = (child: any): boolean => {
      if (typeof child === 'string') {
        return child.trim().length > 0;
      }
      if (typeof child === 'number') {
        return true;
      }
      if (isVNode(child)) {
        // If VNode has direct text, it has content
        if (child.text !== undefined && child.text !== null && String(child.text).trim().length > 0) {
          return true;
        }
        // If has children, check recursively
        if (Array.isArray(child.children) && child.children.length > 0) {
          // If any child has content, return true
          const hasAnyContent = child.children.some(hasContent);
          if (hasAnyContent) {
            return true;
          }
        }
        // If no children or all empty, check if VNode itself has meaningful attributes
        // If has sid, data-decorator-sid (from attrs), attrs, style, it's a meaningful VNode
        if (child.sid || child.attrs?.[DOMAttribute.DECORATOR_SID]) {
          return true;
        }
        // Only decorator-related attrs are considered meaningful content
        if (child.attrs) {
          const decoratorAttrKeys = Object.keys(child.attrs).filter(key =>
            key.startsWith('data-decorator-')
          );
          if (decoratorAttrKeys.length > 0) {
            return true;
          }
        }
        if (child.style && Object.keys(child.style).length > 0) {
          return true;
        }
        // If nothing, it's an empty VNode
        return false;
      }
      // null, undefined, etc. have no content
      return false;
    };

    // Filter out empty nodes before returning
    const filtered = nodes.filter(node => {
      const has = hasContent(node);
      if (process.env.NODE_ENV === 'test' && currentSid === 'text-1' && !has) {
        logger.debug(LogCategory.VNODE, 'filtered out empty inline-text node', {
          tag: node.tag,
          text: node.text,
          childrenCount: Array.isArray(node.children) ? node.children.length : 0,
          sid: node.sid,
          decoratorSid: node.attrs?.['data-decorator-sid'],
          attrs: node.attrs,
          style: node.style
        });
      }
      return has;
    });
    if (process.env.NODE_ENV === 'test' && currentSid === 'text-1') {
      // Helper function to extract text from a child (recursively if needed)
      const extractChildText = (child: any): string | number | undefined => {
        if (typeof child === 'string' || typeof child === 'number') {
          return child;
        }
        if (typeof child === 'object' && child !== null) {
          // If child has direct text property, use it
          if (child.text !== undefined && child.text !== null) {
            return child.text;
          }
          // If child has children, recursively find text
          if (Array.isArray(child.children) && child.children.length > 0) {
            // For mark/decorator nodes, we should find actual text content
            // Try to find first text child recursively
            for (const grandChild of child.children) {
              const text = extractChildText(grandChild);
              if (text !== undefined) {
                return text;
              }
            }
          }
          // If no text found, return undefined (but this should not happen for mark/decorator with content)
          return undefined;
        }
        return undefined;
      };

      logger.debug(LogCategory.VNODE, 'inline-text nodes', filtered.map(node => ({
        tag: node.tag,
        className: node.attrs?.className,
        decoratorSid: node.attrs?.['data-decorator-sid'],
        text: node.text,
        childCount: Array.isArray(node.children) ? node.children.length : 0,
        childTexts: Array.isArray(node.children)
          ? node.children.map(extractChildText)
          : []
      })));
    }
    return filtered;
  }

  /**
   * Convert decorator ranges from full text to markRun-relative
   * 
   * @param inlineDecorators - Array of inline decorators
   * @param markRun - TextRun to convert ranges relative to
   * @returns Array of decorators with markRun-relative ranges
   */
  private _convertDecoratorRangesToMarkRunRelative(
    inlineDecorators: Decorator[],
    markRun: TextRun
  ): Decorator[] {
    return inlineDecorators.map(d => {
      const range = this.decoratorProcessor.getDecoratorRange(d);
      if (isNullOrUndefined(range.start) || isNullOrUndefined(range.end)) return d;

      // Check if decorator overlaps with this markRun
      if (range.end <= markRun.start || range.start >= markRun.end) {
        // Decorator doesn't overlap with this markRun, return null to filter out
        return null;
      }

      // Convert to markRun-relative range
      const relativeStart = Math.max(0, range.start - markRun.start);
      const relativeEnd = Math.min(markRun.text.length, range.end - markRun.start);

      // Create a new decorator with markRun-relative range
      return {
        ...d,
        target: {
          ...d.target,
          startOffset: relativeStart,
          endOffset: relativeEnd
        }
      };
    }).filter((d): d is Decorator => d !== null);
  }

  /**
   * Process decorator runs - handle before/after/overlay decorators
   * 
   * @param decoratorRun - Decorator run to process
   * @param inner - Inner VNode (text or marked run)
   * @param nodes - Array to add processed nodes to
   * @param markRun - Original mark run (for context)
   */
  private _processDecoratorRuns(
    decoratorRun: any,
    inner: VNode,
    nodes: VNode[],
    markRun: TextRun
  ): void {
    // Process multiple decorators (before/after, etc.)
    const decoratorsToProcess = decoratorRun.decorators || (decoratorRun.decorator ? [decoratorRun.decorator] : []);

    if (decoratorsToProcess.length > 0) {
      // before decorators
      const beforeDecorators = decoratorsToProcess.filter((d: Decorator) =>
        d.category === 'inline' && (d.position === 'before')
      );
      // after decorators
      const afterDecorators = decoratorsToProcess.filter((d: Decorator) =>
        d.category === 'inline' && (d.position === 'after')
      );
      // overlay/inside decorators (wrapping text)
      const overlayDecorators = decoratorsToProcess.filter((d: Decorator) =>
        !(d.category === 'inline' && (d.position === 'before' || d.position === 'after'))
      );

      // Add before decorators first
      for (const decorator of beforeDecorators) {
        const decoratorVNode = this.decoratorProcessor.buildDecoratorVNode(
          decorator,
          (template, data, options) => this._buildElement(template, data, options)
        );
        nodes.push(decoratorVNode);
      }

      // Wrap text with overlay decorators (innermost first)
      let wrappedInner = inner;
      for (const decorator of overlayDecorators) {
        const decoratorVNode = this.decoratorProcessor.buildDecoratorVNode(
          decorator,
          (template, data, options) => this._buildElement(template, data, options)
        );
        // overlay decorator should use actual text/mark VNode as children
        // instead of children provided by renderer
        // Even if placeholder children are defined in template, clear to prevent duplicate rendering
        decoratorVNode.children = [];
        decoratorVNode.children.push(wrappedInner);
        wrappedInner = decoratorVNode;
      }

      // Add text (or wrapped text)
      nodes.push(wrappedInner);

      // Add after decorators
      for (const decorator of afterDecorators) {
        const decoratorVNode = this.decoratorProcessor.buildDecoratorVNode(
          decorator,
          (template, data, options) => this._buildElement(template, data, options)
        );
        nodes.push(decoratorVNode);
      }
    } else {
      nodes.push(inner);
    }
  }


  /**
   * Build registered component - handles ElementTemplate and function-based components
   * 
   * @param registeredComponent - The registered component
   * @param template - ComponentTemplate
   * @param data - Model data
   * @param buildOptions - Build options
   * @returns VNode or null
   */
  private _buildRegisteredComponent(
    registeredComponent: any,
    template: ComponentTemplate,
    data: ModelData,
    buildOptions: VNodeBuildOptions
  ): VNode | null {
    // Resolve props: prioritize props set in build()
    const resolvedProps = resolveComponentProps(template, data);

    // Convert children to content
    if (template.children && template.children.length > 0) {
      const contentVNodes: VNode[] = [];
      for (const child of template.children) {
        if ((child as any).type === 'element') {
          contentVNodes.push(this._buildElement(child as ElementTemplate, data, buildOptions));
        } else if ((child as any).type === 'component') {
          // Pass ComponentTemplate's props as data (item component uses data('text'))
          const childProps = (child as ComponentTemplate).props || {};
          const childData = { ...data, ...childProps };
          const childVNode = this._buildComponent(child as ComponentTemplate, childData, buildOptions);
          this._addVNodeIfNotNull(childVNode, contentVNodes);
        }
      }
      resolvedProps.content = contentVNodes;
    }

    // This is a registered component, handle it
    const mergedData = { ...data, ...resolvedProps } as any;
    // Ensure child component identity reflects this component, not parent
    mergedData.stype = template.name;

    // getComponent() always returns ExternalComponent, so
    // isElementTemplate(registeredComponent) is always false
    // ElementTemplate check is unnecessary (not executed)

    const _key = `${template.name}-${mergedData?.sid ?? 'noid'}`;
    // Get component state from ComponentManager if available
    const componentState = this._getComponentStateForBuild(template, mergedData || {}, resolvedProps);
    // Try to get state instance from ComponentManager
    let stateInstance: any = undefined;
    if (this.componentManager) {
      const instance = this.componentManager.getInstance((mergedData as any)?.sid || _key);
      if (instance) {
        stateInstance = (instance as any).__stateInstance;
      }
    }
    const ctx = this._makeContext(_key, componentState, resolvedProps, mergedData || {}, {
      instance: stateInstance
    });
    
    // Find component function (either direct function or template function)
    const componentFunction = isFunction(registeredComponent) 
      ? registeredComponent as any
      : (registeredComponent.template && isFunction(registeredComponent.template) 
          ? registeredComponent.template 
          : null);
    
    if (!componentFunction) {
      return null;
    }
    
    // Execute component function to get ElementTemplate
    const elementTemplate = componentFunction(resolvedProps, mergedData, ctx) as ElementTemplate;
    
    // For contextual components registered via registerContextComponent, pass full mergedData so data() calls can access all properties
    // For external components, pass only id and type to avoid overriding component's template attributes
    const isContextualComponent = (registeredComponent as any).managesDOM === false;
    const componentData = isContextualComponent ? mergedData : { id: (mergedData as any)?.sid, type: (mergedData as any)?.type };
    
    // Build element from template
    const vnode = this._buildElement(elementTemplate, componentData, buildOptions);
    const attrs: Record<string, any> = vnode.attrs || {};
    vnode.attrs = attrs;
    
    // Apply component identity attributes
    assignComponentIdentityAttrs(attrs, template.name, mergedData, { defaultStype: (componentData as any)?.type ?? 'component' }, (id) => this.ensureUniqueId(id));
    
    // Attach component info with separated props and model
    attachComponentInfoWithSeparatedData(
      vnode,
      template.name,
      sanitizePropsUtil(resolvedProps),
      mergedData,
      resolveDecoratorsFromBuildOptions(buildOptions)
    );
    
    return vnode;
  }


  /**
   * Render component children
   * 
   * @param template - ComponentTemplate
   * @param data - Model data
   * @param props - Resolved props (will be modified to add children)
   * @param buildOptions - Build options
   * @returns Array of child VNodes
   */
  private _renderComponentChildren(
    template: ComponentTemplate,
    data: ModelData,
    props: Record<string, any>,
    buildOptions: VNodeBuildOptions
  ): VNode[] {
    const children: VNode[] = [];
    if (template.children) {
      template.children.forEach(child => {
        if (isStringOrNumber(child)) {
          // Pass text as props
          if (!props.children) props.children = [];
          props.children.push(String(child));
        } else if ((child as any).type === 'element') {
          children.push(this._buildElement(child as ElementTemplate, data, buildOptions));
        } else if (isDataTemplate(child)) {
          const value = (child as DataTemplate).getter ? (child as DataTemplate).getter?.(data) : getDataValue(data, (child as DataTemplate).path!);
          const resolved = isNullOrUndefined(value) ? (child as DataTemplate).defaultValue : value;
          if (!props.children) props.children = [];
          props.children.push(String(resolved ?? ''));
        }
        // Other types handled recursively
        else if (isComponentTemplate(child)) {
          const childComponent = this._buildComponent(child as ComponentTemplate, data, buildOptions);
          if (childComponent) {
            children.push(childComponent);
          }
        }
        // Skip each/conditional here (handled elsewhere for simplicity)
      });
    }
    return children;
  }


}

// Global VNodeBuilder instance for convenience
const globalBuilder = new VNodeBuilder();

/**
 * Builds a VNode from a node type using the global builder
 * 
 * This is a convenience function that uses the global VNodeBuilder instance
 * to build VNodes. It's the main entry point for most VNode creation.
 * 
 * @param nodeType - The type of node to build (must be registered)
 * @param data - Model data for data binding
 * @returns VNode ready for DOM rendering
 */
export function buildVNode(nodeType: string, data: ModelData = {}): VNode {
  return globalBuilder.build(nodeType, data);
}

/**
 * Alias for buildVNode - more intuitive name
 */
export const build = buildVNode;

/**
 * Alias for buildVNode - alternative naming
 */
export const make = buildVNode;

/**
 * Gets the global VNodeBuilder instance
 * 
 * @returns The global VNodeBuilder instance
 */
export function getGlobalBuilder(): VNodeBuilder {
  return globalBuilder;
}
