/**
 * DOM Operations: Core DOM manipulation utilities
 * - Element creation and updates
 * - Attribute and style management
 * - Namespace handling
 */
import { VNode, VNodeTag, DOMAttribute } from './vnode/types';
import { DOMWorkInProgress } from './work-in-progress';
import { 
  setAttributeWithNamespace, 
  removeAttributeWithNamespace, 
  shouldSkipAttribute,
  getNamespaceForTag,
  createElementWithNamespace
} from './namespace-utils';
import { isAutoGeneratedSid } from './vnode/utils/sid-source';

export class DOMOperations {
  /**
   * Create DOM element from VNode
   */
  public createElement(vnode: VNode, parentElement?: HTMLElement): HTMLElement {
    const tag = vnode.tag || 'div';
    const namespace = getNamespaceForTag(tag, parentElement);
    const element = createElementWithNamespace(tag, namespace);
    
    // Preserve schema identifiers on element for selection/tests
    const vnodeSid = (vnode as any).sid;
    if (vnodeSid) {
      (element as any).sid = vnodeSid;
    }

    const sidAttr = vnode.attrs?.[DOMAttribute.BC_SID];
    const fallbackId = vnode.attrs?.id;
    const sidToExpose = sidAttr
      ?? (!isAutoGeneratedSid(vnode) ? vnodeSid : undefined)
      ?? fallbackId;
    if (sidToExpose) {
      element.setAttribute(DOMAttribute.BC_SID, String(sidToExpose));
    }

    // Set attributes (초기 생성이므로 prevAttrs는 undefined)
    if (vnode.attrs) {
      this.updateAttributes(element, undefined, vnode.attrs);
    }
    
    // Set styles (초기 생성이므로 prevStyles는 undefined)
    if (vnode.style) {
      this.updateStyles(element, undefined, vnode.style);
    }
    // Set initial text content when there are no children
    if (vnode.text != null && (!vnode.children || vnode.children.length === 0)) {
      element.textContent = String(vnode.text);
    }
    // Ensure initial children are materialized when present
    if (Array.isArray(vnode.children) && vnode.children.length > 0) {
      for (const child of vnode.children) {
        if (child && typeof child === 'object') {
          // Use vnodeToDOM for recursive conversion
          const node = this.vnodeToDOM(child as any, element as HTMLElement);
          element.appendChild(node);
        } else if (typeof child === 'string' || typeof child === 'number') {
          element.appendChild(document.createTextNode(String(child)));
        }
      }
    }
    
    return element;
  }

  /**
   * Update text node content (추적 가능하도록 별도 메서드로 분리)
   */
  public updateTextContent(textNode: Text, prevText: string, nextText: string): void {
    if (prevText !== nextText) {
      textNode.textContent = nextText;
    }
  }

  /**
   * Update element attributes with namespace support
   * Compares prevVNode and nextVNode to update only changed attributes
   * Removes attributes that exist in prevVNode but not in nextVNode
   */
  public updateAttributes(
    element: HTMLElement, 
    prevAttrs: Record<string, any> | undefined,
    nextAttrs: Record<string, any>
  ): void {
    // IMPORTANT: prevAttrs가 없으면 기존 DOM의 속성을 읽어서 보존
    // 이는 renderFiberNode에서 DOM을 재사용할 때 기존 속성을 보존하기 위함
    let actualPrevAttrs = prevAttrs;
    if (!actualPrevAttrs) {
      // 기존 DOM의 속성을 읽어서 prevAttrs로 사용
      actualPrevAttrs = {};
      
      // class/className
      const existingClass = element.getAttribute('class');
      if (existingClass) {
        actualPrevAttrs['class'] = existingClass;
        actualPrevAttrs['className'] = existingClass;
      }
      
      // style
      const existingStyle = element.getAttribute('style');
      if (existingStyle) {
        actualPrevAttrs['style'] = existingStyle;
      }
      
      // data-* 속성들
      for (let i = 0; i < element.attributes.length; i++) {
        const attr = element.attributes[i];
        if (attr.name.startsWith('data-')) {
          actualPrevAttrs[attr.name] = attr.value;
        }
      }
    }
    
    // 1. prevVNode에 있지만 nextVNode에 없는 속성 제거
    // IMPORTANT: data-bc-sid는 createElement에서 vnode.sid로 설정되므로 보존해야 함
    if (actualPrevAttrs) {
      for (const key of Object.keys(actualPrevAttrs)) {
        if (!(key in nextAttrs)) {
          // data-bc-sid는 보존 (createElement에서 vnode.sid로 설정됨)
          if (key === DOMAttribute.BC_SID) {
            continue;
          }
          // 제거
          if (key === 'className' || key === 'class') {
            element.removeAttribute('class');
            (element as any).className = '';
          } else {
            removeAttributeWithNamespace(element, key);
          }
        }
      }
    }
    
    // 2. nextVNode 속성 적용/업데이트 (prevVNode와 다르면)
    for (const [key, value] of Object.entries(nextAttrs)) {
      if (shouldSkipAttribute(element, key)) {
        continue;
      }
      
      // Treat undefined/null as removal
      if (value === undefined || value === null) {
        if (key === 'className' || key === 'class') {
          element.removeAttribute('class');
          (element as any).className = '';
        } else if (actualPrevAttrs && key in actualPrevAttrs) {
          removeAttributeWithNamespace(element, key);
        }
        continue;
      }
      
      // prevVNode와 다르면 업데이트 (prevVNode가 없으면 항상 업데이트)
      const prevValue = actualPrevAttrs?.[key];
      if (prevValue !== value) {
        if (key === 'className' || key === 'class') {
            (element as any).className = String(value);
            element.setAttribute('class', String(value));
        } else {
          setAttributeWithNamespace(element, key, value);
        }
      }
    }
  }


  /**
   * Update element styles
   * Compares prevVNode and nextVNode to update only changed styles
   * Removes styles that exist in prevVNode but not in nextVNode
   */
  public updateStyles(
    element: HTMLElement,
    prevStyles: Record<string, any> | undefined,
    nextStyles: Record<string, any>
  ): void {
    // 1. prevVNode에 있지만 nextVNode에 없는 스타일 제거
    if (prevStyles) {
      for (const key of Object.keys(prevStyles)) {
        if (!(key in nextStyles)) {
          const cssProperty = key.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);
          element.style.removeProperty(cssProperty);
        }
      }
    }
    
    // 2. nextVNode 스타일 적용/업데이트 (prevVNode와 다르면)
    for (const [key, value] of Object.entries(nextStyles)) {
      // Convert camelCase to kebab-case (e.g., 'fontSize' -> 'font-size')
      const cssProperty = key.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);
      
      // prevVNode와 다르면 업데이트 (prevVNode가 없으면 항상 업데이트)
      const prevValue = prevStyles?.[key];
      if (prevValue !== value) {
        element.style.setProperty(cssProperty, String(value));
        
        // Verify it was set
        const actualValue = element.style.getPropertyValue(cssProperty);
        
        // If setProperty didn't work, try direct assignment as fallback
        if (!actualValue) {
          (element.style as any)[key] = String(value);
        }
      }
    }
  }

  /**
   * Set a single attribute with namespace support
   * Use this instead of element.setAttribute() directly
   */
  public setAttribute(element: HTMLElement, key: string, value: string | number | boolean): void {
    setAttributeWithNamespace(element, key, value);
  }

  /**
   * Create a simple element with just a tag (for Reconciler use)
   * Handles namespace automatically
   */
  public createSimpleElement(tag: string, parentElement?: HTMLElement): HTMLElement {
    const namespace = getNamespaceForTag(tag, parentElement);
    return createElementWithNamespace(tag, namespace);
  }

  /**
   * Update attributes with support for removal (undefined values)
   */
  public updateAttributesWithRemoval(element: HTMLElement, attrs: Record<string, any>): void {
    for (const [key, value] of Object.entries(attrs)) {
      if (shouldSkipAttribute(element, key)) {
        continue;
      }
      if (key === 'class') {
        if (value === undefined || value === null) {
          element.removeAttribute('class');
          (element as any).className = '';
        } else {
          (element as any).className = String(value);
          element.setAttribute('class', String(value));
        }
        continue;
      }
      
      if (value === undefined || value === null) {
        // Remove attribute when value is undefined
        removeAttributeWithNamespace(element, key);
      } else {
        setAttributeWithNamespace(element, key, value);
      }
    }
  }

  /**
   * Insert DOM node into the tree
   */
  public insertDOMNode(node: Node, wip: DOMWorkInProgress, container?: HTMLElement): void {
    // DOM 노드를 WIP에만 설정하고, 실제 DOM 추가는 finalizeDOMUpdate에서 처리
    wip.domNode = node;
  }

  /**
   * Finalize DOM update by appending nodes to their parents or the container
   */
  public finalizeDOMUpdate(wip: DOMWorkInProgress, container: HTMLElement, context: any): void {
    // Skip portal nodes - they are handled separately by PortalManager
    if (wip.type === 'portal' || wip.vnode?.tag === VNodeTag.PORTAL) {
      return;
    }
    
    // Handle deletion first - if toDelete is true, we should remove existing DOM node
    if ((wip as any).toDelete) {
      // For deletion, domNode should already be set from findTargetNode in Process Phase
      // If not set, or if set incorrectly, try to find it from parent by matching tag and text
      // Important: Exclude children that are already matched to other WIP nodes
      // Also verify that existing domNode matches the vnode (text and tag) before using it
      let domNodeToRemove = wip.domNode;
      
      // Verify existing domNode matches vnode (for deletion, vnode is the previousVNode)
      if (domNodeToRemove && wip.vnode) {
        const matches = (
          (!wip.vnode.tag && domNodeToRemove.nodeType === Node.TEXT_NODE && domNodeToRemove.textContent === String(wip.vnode.text)) ||
          (wip.vnode.tag && domNodeToRemove instanceof HTMLElement && 
           domNodeToRemove.tagName.toLowerCase() === wip.vnode.tag.toLowerCase() &&
           (wip.vnode.text === undefined || domNodeToRemove.textContent === String(wip.vnode.text)))
        );
        if (!matches) {
          domNodeToRemove = undefined;
        }
      }
      
      if (!domNodeToRemove && wip.parent?.domNode) {
        const parent = wip.parent.domNode as HTMLElement;
        // Prefer removing host wrapper by SID if previous vnode had a sid
        const desiredPrevSid = (wip.previousVNode?.attrs as any)?.[DOMAttribute.BC_SID] || (wip.vnode?.attrs as any)?.[DOMAttribute.BC_SID];
        if (desiredPrevSid) {
          const wrapperBySid = Array.from(parent.children).find((el: Element) => (el as HTMLElement).getAttribute(DOMAttribute.BC_SID) === String(desiredPrevSid)) as HTMLElement | undefined;
          if (wrapperBySid) {
            domNodeToRemove = wrapperBySid;
          }
        }
        const matchingChildren = Array.from(parent.children).filter((child: Element) => {
          if (wip.vnode?.tag) {
            return child.tagName.toLowerCase() === wip.vnode.tag.toLowerCase();
          }
          return false;
        }) as HTMLElement[];
        
        const alreadyMatchedDomNodes = new Set<HTMLElement>();
        if (wip.parent && 'children' in wip.parent) {
          try {
            const parentChildren = (wip.parent as any).children as any[];
            if (Array.isArray(parentChildren)) {
              for (const childWip of parentChildren) {
                if (!(childWip as any)?.toDelete && childWip?.domNode) {
                  alreadyMatchedDomNodes.add(childWip.domNode as HTMLElement);
                }
              }
            }
          } catch {}
        }
        
        const unmatchedChildren = matchingChildren.filter(child => 
          !alreadyMatchedDomNodes.has(child)
        );
        
        if (wip.vnode?.text !== undefined && unmatchedChildren.length > 0) {
          const textMatchingChildren = unmatchedChildren.filter(child => 
            child.textContent === String(wip.vnode.text)
          );
          if (textMatchingChildren.length > 0) {
            domNodeToRemove = textMatchingChildren[0];
          }
        }
        if (!domNodeToRemove && unmatchedChildren.length > 0) {
          domNodeToRemove = unmatchedChildren[0];
        }
        if (!domNodeToRemove && matchingChildren.length > 0) {
          domNodeToRemove = matchingChildren[matchingChildren.length - 1];
        }
      }
      
      if (domNodeToRemove) {
        wip.domNode = domNodeToRemove;
      }
      
      if (wip.domNode) {
        const parent = (wip.parent?.domNode as HTMLElement) || container;
        try {
          if (wip.domNode.parentNode === parent) {
            parent.removeChild(wip.domNode);
          }
        } catch {}
      }
      return;
    }
    
    // Ensure DOM node exists for this WIP (only for non-deletion nodes)
    // For root nodes and children nodes, check if node already exists before creating
    // First, try to get domNode from targetNode (set by processWIP in Process Phase)
    // Also check if processElementNode already set domNode (from _originalWip or directly)
    // IMPORTANT: processElementNode may have already set domNode in Process Phase
    // This happens when processElementNode finds and reuses an existing DOM node
    // In that case, domNode is already set and we don't need to find it again
    // We must check this FIRST before trying to find existing nodes, to avoid duplicate reuse
    if (!wip.domNode) {
      // Check targetNode from original WIP (before conversion)
      const originalWip = (wip as any)._originalWip;
      if (originalWip?.targetNode) {
        wip.domNode = originalWip.targetNode as any;
      } else if ((wip as any).targetNode) {
        wip.domNode = (wip as any).targetNode as any;
      }
    }
    // If root WIP incorrectly points to container as domNode, clear it to force element creation
    if (!wip.parent && wip.domNode === container && wip.vnode?.tag) {
      wip.domNode = null as any;
    }
    
    // If domNode is already set (by processElementNode), we should skip the reuse logic below
    // This is critical to prevent duplicate node reuse
    // processElementNode already matched this node in Process Phase
    
    // Only try to find existing nodes if domNode is not already set
    // If processElementNode already set domNode, we should NOT try to reuse another node
    // This prevents conflicts where multiple WIPs try to reuse the same DOM node
    if (!wip.domNode) {
      const vnode = wip.vnode as VNode;
      if (typeof vnode === 'object' && vnode) {
        // For root nodes (no parent), check if node already exists in container
        // Use previousVNode.tag for element → text conversion cases
        if (!wip.parent && wip.previousVNode) {
          // If previousVNode had a tag, try to find existing element
          if (wip.previousVNode.tag) {
            const existingRoot = Array.from(container.children).find((child: Element) => 
              child.tagName.toLowerCase() === wip.previousVNode!.tag!.toLowerCase()
            ) as HTMLElement | undefined;
            if (existingRoot) {
              wip.domNode = existingRoot;
            }
          }
          // If vnode is a text node (no tag), try to find existing text node in childNodes
          // This handles element → text conversion where processElementNode already replaced the element
          if (!vnode.tag && vnode.text !== undefined) {
            const existingTextNode = Array.from(container.childNodes).find((node: Node) => 
              node.nodeType === Node.TEXT_NODE && node.textContent === String(vnode.text)
            ) as Text | undefined;
            if (existingTextNode) {
              wip.domNode = existingTextNode;
            }
          }
        }
        // For child nodes, check if node already exists in parent
        // Important: Exclude children that are already matched to other WIP nodes
        // This includes nodes set by processElementNode in Process Phase
        else if (wip.parent?.domNode && vnode.tag && wip.previousVNode) {
          const parent = wip.parent.domNode as HTMLElement;
          
          // Get already matched children by checking parent's children WIP
          // Important: Check both original WIP (from reconcile package) and converted DOMWIP
          // Also include nodes that were already set by processElementNode in Process Phase
          const alreadyMatchedDomNodes = new Set<HTMLElement>();
          if (wip.parent) {
            try {
              // Access parent.children (may trigger lazy conversion, but we need it for reuse check)
              const parentChildren = (wip.parent as any).children as any[];
              if (Array.isArray(parentChildren)) {
                for (const childWip of parentChildren) {
                  // Skip deletion nodes and the current node itself
                  if (childWip === wip || (childWip as any)?.toDelete) {
                    continue;
                  }
                  
                  // Get domNode from childWip (may be DOMWIP or original WIP)
                  // Priority: 1) domNode (set by processElementNode), 2) targetNode (set in Process Phase), 3) _originalWip.targetNode
                  // Important: processElementNode may have already set domNode in Process Phase
                  let childDomNode: HTMLElement | undefined;
                  
                  // First check domNode (set by processElementNode in Process Phase)
                  // Check both DOMWIP and original WIP for domNode
                  if (childWip?.domNode) {
                    childDomNode = childWip.domNode as HTMLElement;
                  } else if ((childWip as any)?._originalWip?.domNode) {
                    // Check original WIP's domNode (if converted to DOMWIP)
                    childDomNode = (childWip as any)._originalWip.domNode as HTMLElement;
                  } else if (childWip?.targetNode) {
                    childDomNode = childWip.targetNode as HTMLElement;
                  } else if ((childWip as any)?._originalWip?.targetNode) {
                    childDomNode = (childWip as any)._originalWip.targetNode as HTMLElement;
                  }
                  
                  // Also check if processElementNode set domNode via findExistingDOMNodeInContainer
                  // This is critical for preventing duplicate node reuse
                  // If childWip has a domNode set, it means processElementNode already matched it
                  // We must exclude this node from reuse to prevent conflicts
                  
                  if (childDomNode) {
                    alreadyMatchedDomNodes.add(childDomNode);
                  }
                }
              }
            } catch {
              // If accessing children causes issues, continue without exclusion
            }
          }
          
          // Find existing child, excluding already matched ones
          // Match by prevVNode first (for updates), then by vnode (for exact matches)
          // Note: If processElementNode already updated text, child.textContent may already match vnode.text
          // Priority: 1) prevVNode text (actual DOM state), 2) vnode text (updated by processElementNode), 3) tag only
          const tag = vnode.tag || wip.previousVNode?.tag || '';
          const existingChild = Array.from(parent.children).find((child: Element) => {
            // Skip if already matched to another WIP
            if (alreadyMatchedDomNodes.has(child as HTMLElement)) {
              return false;
            }
            if (!tag || child.tagName.toLowerCase() !== tag.toLowerCase()) {
              return false;
            }
            // Priority 1: Match by prevVNode text (actual DOM state before any updates)
            // This is most reliable for finding the correct node to update
            // However, if processElementNode already updated the text, this might not match
            // So we check the actual DOM state (textContent) against prevVNode.text
            // But we need to be careful: if processElementNode updated it, textContent might match vnode.text instead
            // So we check both prevVNode.text and vnode.text, but prioritize prevVNode.text
            if (wip.previousVNode?.text !== undefined) {
              // First check if DOM node's text matches prevVNode.text (before processElementNode update)
              // This is the most reliable match for finding the correct node to reuse
              if (child.textContent === String(wip.previousVNode.text)) {
                return true;
              }
            }
            // Priority 2: Match by vnode text (text may have been updated by processElementNode)
            // This handles cases where processElementNode already updated the DOM
            // But we need to be careful: if vnode.text matches, it might be because processElementNode updated it
            // So we only match if the DOM text actually matches vnode.text
            if (vnode.text !== undefined) {
              if (child.textContent === String(vnode.text)) {
                return true;
              }
            }
            // Priority 3: Match by tag only (first matching child that's not already matched)
            // This is a fallback but should be avoided when possible
            return true;
          }) as HTMLElement | undefined;
          if (existingChild) {
            wip.domNode = existingChild;
            const currentText = existingChild.textContent;
            const expectedText = vnode.text !== undefined ? String(vnode.text) : undefined;
            
            // Update text content if it has changed
            if (expectedText !== undefined && currentText !== expectedText) {
              existingChild.textContent = expectedText;
              
            }
            
          }
        }
        
        // Only create if still not found
        if (!wip.domNode) {
        if (!vnode.tag && vnode.text !== undefined) {
          wip.domNode = document.createTextNode(String(vnode.text));
            
        } else {
          const element = this.createElement(vnode, (wip.parent?.domNode as HTMLElement) || container);
          // Only set textContent if there are no children (text-only element)
          if (vnode.text && !(Array.isArray(vnode.children) && vnode.children.length > 0)) {
            (element as HTMLElement).textContent = String(vnode.text);
          }
          wip.domNode = element;
            
          }
        }
      }
    }

    // DOM 업데이트 최종화
    if (wip.domNode) {
      // Ensure parent domNode exists before placing children
      if (wip.parent && !wip.parent.domNode && (wip.parent.vnode as any)?.tag) {
        const parentElement = this.createElement(wip.parent.vnode as VNode, container);
        wip.parent.domNode = parentElement;
        // Attach parent to container if not already attached
        if (!Array.from(container.children).includes(parentElement)) {
          container.appendChild(parentElement);
        }
      }
      if (wip.parent?.domNode) {
        // 부모가 있는 경우 부모에 추가
        const parent = wip.parent.domNode as HTMLElement;
        
        // Skip over-strict parent/child verification; rely on source order and insertBefore
        
        // Wrapper 금지: 자식 노드를 임의의 div로 감싸지 않는다 (SID_DRIVEN_LIFECYCLE)

        // Check if wip.domNode is already in a different parent
        const currentParent = wip.domNode.parentNode;
        if (currentParent && currentParent !== parent) {
          
          
          // Remove from wrong parent before inserting into correct parent
          try {
            (currentParent as HTMLElement).removeChild(wip.domNode);
            
          } catch {}
        }
        
        const existingNode = parent.querySelector(`[data-wip-sid="${wip.sid}"]`);
        
        // 순환 포함 방어: 자식이 부모를 포함하면 append 시도는 예외 발생(HierarchyRequestError)
        if ((wip.domNode as Node).contains(parent)) {
          try {
            console.error('[DOMOperations] finalizeDOMUpdate:cycle-detected (child contains parent) skip append', {
              sid: (wip as any).sid,
              childTag: (wip.domNode as HTMLElement).nodeName,
              parentTag: parent.nodeName
            });
          } catch {}
          return;
        }
        
        // DOM이 이미 부모의 직접 자식인지 확인 (중복 append 방지)
        const isAlreadyInParent = Array.from(parent.childNodes).includes(wip.domNode as ChildNode);
        const hasMarker = !!(wip.domNode as any).__barocss_inserted;
        
        // Find previous sibling by checking parent's children WIP
        // Reconcile is pure VNode-based - no DOM queries
        // For text nodes, we need to check parent.childNodes (not just parent.children)
        let prevSiblingDom: Node | null | undefined = (wip as any).prevSiblingDom;
        if (!prevSiblingDom && wip.parent && 'children' in wip.parent) {
          try {
            const parentChildren = (wip.parent as any).children as any[];
            if (Array.isArray(parentChildren)) {
              const currentIndex = wip.desiredIndex ?? wip.orderIndex ?? -1;
              // Find the previous sibling that has been finalized (has domNode)
              // Sort siblings by desiredIndex/orderIndex to find the correct previous sibling
              // This is pure WIP-based - no DOM queries
              const sortedSiblings = parentChildren
                .filter((s: any) => s.domNode && !(s as any)?.toDelete)
                .sort((a: any, b: any) => {
                  const aIndex = a.desiredIndex ?? a.orderIndex ?? -1;
                  const bIndex = b.desiredIndex ?? b.orderIndex ?? -1;
                  return aIndex - bIndex;
                });
              
              // Find the sibling that should be before current node
              // Use the last sibling with index < currentIndex (immediate previous)
              let lastPrevSibling: any = null;
              for (let i = 0; i < sortedSiblings.length; i++) {
                const sibling = sortedSiblings[i];
                const siblingIndex = sibling.desiredIndex ?? sibling.orderIndex ?? -1;
                if (siblingIndex < currentIndex) {
                  lastPrevSibling = sibling;
                } else {
                  break;
                }
              }
              if (lastPrevSibling?.domNode) {
                prevSiblingDom = lastPrevSibling.domNode as Node;
                  
              } else {
                
              }
            }
          } catch {
            // If accessing children causes issues, fall back to default behavior
          }
        }
        
        // Ensure prevSiblingDom belongs to the same parent; otherwise ignore it
        if (prevSiblingDom && prevSiblingDom.parentNode !== parent) {
          prevSiblingDom = null;
        }
        // For text nodes, ref should be calculated from parent.childNodes (not just parent.children)
        // Use prevSiblingDom.nextSibling if available, otherwise use parent.firstChild
        let ref = prevSiblingDom ? (prevSiblingDom.nextSibling) : parent.firstChild;
        // If ref is not a child of parent (can happen if prevSiblingDom was detached), fallback to null
        if (ref && ref.parentNode !== parent) {
          ref = null as any;
        }

        // Ensure text content is updated BEFORE DOM operations
        // This is important for reused nodes where text may have changed
        // Update before reorder/insert to prevent text loss
        if (wip.vnode?.text !== undefined && wip.domNode instanceof HTMLElement) {
          const currentText = wip.domNode.textContent;
          const expectedText = String(wip.vnode.text);
          
          if (currentText !== expectedText) {
            wip.domNode.textContent = expectedText;
            
          }
        }
        
        // Before inserting, check if a node with the same sid already exists in parent
        // This prevents duplicate nodes when matching fails, but only for nodes without key-based reconciliation
        // For keyed nodes, we rely on key-based matching from ChildrenReconciler
        if (!wip.vnode?.key && wip.vnode?.attrs?.[DOMAttribute.BC_SID]) {
          const currentSid = wip.vnode.attrs[DOMAttribute.BC_SID];
          const existingNodeWithSameSid = Array.from(parent.children).find((child: Element) => {
            if (child === wip.domNode) return false; // Skip self
            const childSid = child.getAttribute(DOMAttribute.BC_SID);
            return childSid === currentSid;
          }) as HTMLElement | undefined;
          
          if (existingNodeWithSameSid && existingNodeWithSameSid !== wip.domNode) {
            
            // Remove the duplicate node
            if (existingNodeWithSameSid.parentNode) {
              existingNodeWithSameSid.parentNode.removeChild(existingNodeWithSameSid);
            }
          }
        }

        // Use insertBefore to position the node correctly (works even if already in DOM)
        if (ref) {
          // Skip if ref is the same as domNode (would do nothing)
          if (wip.domNode === ref) {
            // Already in correct position (ref points to itself)
          } else if (wip.domNode.parentNode !== parent) {
            // Not already a direct child of parent - insert it
            try {
              parent.insertBefore(wip.domNode, ref);
            } catch {
              // If ref is invalid for this parent, append as fallback
              parent.appendChild(wip.domNode);
            }
          } else if (wip.domNode.parentNode === parent) {
            // Already a direct child - check if position is correct
            const currentNextSibling = wip.domNode.nextSibling;
            // Only reorder if nextSibling is different from expected ref
            // Note: ref is prevSiblingDom.nextSibling, so if domNode.nextSibling !== ref, position is wrong
            if (currentNextSibling !== ref) {
              // Wrong position - reorder
              const beforeText = wip.domNode instanceof HTMLElement ? wip.domNode.textContent : undefined;
              const allChildren = Array.from(parent.children).map((c, i) => ({
                index: i,
                tag: c.tagName,
                text: c.textContent,
                sid: (c as HTMLElement).getAttribute(DOMAttribute.BC_SID)
              }));
              
            try {
              parent.insertBefore(wip.domNode, ref);
            } catch {
              parent.appendChild(wip.domNode);
            }
              const afterText = wip.domNode instanceof HTMLElement ? wip.domNode.textContent : undefined;
              const allChildrenAfter = Array.from(parent.children).map((c, i) => ({
                index: i,
                tag: c.tagName,
                text: c.textContent,
                sid: (c as HTMLElement).getAttribute(DOMAttribute.BC_SID)
              }));
              
            } else {
              // Already in correct position
            }
          }
        } else if (!isAlreadyInParent && !hasMarker) {
          // No reference node and not already in parent - append
          parent.appendChild(wip.domNode);
        }
        
        // Ensure text content is updated again after DOM operations (in case reorder cleared it)
        if (wip.vnode?.text !== undefined && wip.domNode instanceof HTMLElement) {
          const currentText = wip.domNode.textContent;
          const expectedText = String(wip.vnode.text);
          
          if (currentText !== expectedText) {
            wip.domNode.textContent = expectedText;
            
          }
        }
      } else {
        // 루트 노드에 추가할지 결정하기 전에, 노드가 이미 어떤 부모에 속해있는지 확인
        const isInSomeParent = !!wip.domNode.parentNode;
        const hasMarker = !!(wip.domNode as any).__barocss_inserted;
        
        // For text nodes, check if already in container's childNodes (not just children)
        const isTextNode = wip.domNode.nodeType === Node.TEXT_NODE;
        const isAlreadyInContainer = isTextNode
          ? Array.from(container.childNodes).includes(wip.domNode as ChildNode)
          : Array.from(container.children).includes(wip.domNode as Element);
        const containerHasChildren = isTextNode
          ? container.childNodes.length > 0
          : container.children.length > 0;
        
        // 순환 포함 방어: 자식이 컨테이너를 포함하면 append 불가
        if ((wip.domNode as Node).contains(container)) {
          
          return;
        }
        
        // 내부 래퍼 금지: 내부 루트 보조 div를 생성하지 않는다
        const domCtx: any = context || {};
        const vnodeTag = (wip.vnode as any)?.tag;

        // Append to container if it's not already there
        if (!isAlreadyInContainer && !hasMarker) {
          container.appendChild(wip.domNode);
          // If this is the first proper element (e.g., div), set as internal root
          // (isInternalReconcile 체크 제거: 항상 false로 간주)
          if (!domCtx.__internalRootElement && vnodeTag) {
            domCtx.__internalRootElement = wip.domNode as HTMLElement;
          }
        } else if (isAlreadyInContainer) {
          
        } else if (!containerHasChildren && !hasMarker) {
          // Edge case: empty host container sometimes reports node as already placed elsewhere
          // Ensure first child is appended to an empty host
          container.appendChild(wip.domNode);
        }
      }
    } else {
      
    }
  }

  /**
   * Convert VNode to DOM recursively
   */
  public vnodeToDOM(vnode: VNode, parent?: Element | null, data?: any): Node {
    // Text node
    if (!vnode.tag && vnode.text !== undefined) {
      return document.createTextNode(String(vnode.text));
    }
    
    if (!vnode.tag && !vnode.stype && !vnode.text) return document.createTextNode('');
    
    // Use createElement for proper namespace handling
    const element = this.createElement(vnode, parent as HTMLElement);
    
    // Set text content ONLY if there are no children
    // If children exist, they will be processed below and textContent would be overwritten anyway
    if (vnode.text != null && (!vnode.children || vnode.children.length === 0)) {
      element.textContent = String(vnode.text);
    }
    
    // Process children recursively
    if (vnode.children && vnode.children.length > 0) {
      for (const child of vnode.children) {
        if (typeof child === 'object' && child !== null) {
          const childNode = this.vnodeToDOM(child, element, data);
          element.appendChild(childNode);
        } else if (typeof child === 'string' || typeof child === 'number') {
          element.appendChild(document.createTextNode(String(child)));
        }
      }
    }
    
    // Append to parent if provided
    if (parent) {
      parent.appendChild(element);
    }
    
    return element;
  }

}
