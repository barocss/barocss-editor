# Fiber 및 Reconciler 테스트 및 리팩토링 분석

## 현재 상태

### 테스트된 함수들
- ✅ `reconcileWithFiber` - 통합 테스트
- ✅ `reconcileFiberNode` - 통합 테스트
- ✅ `createFiberTree` - 단위 테스트
- ✅ `processPrimitiveTextChildren` - 단위 테스트
- ✅ `removeStaleChildren` - 단위 테스트 (decorator 케이스 포함)
- ✅ `findHostForChildVNode` - 단위 테스트
- ✅ `findHostInParentChildren` - 단위 테스트
- ✅ `createHostElement` - 단위 테스트
- ✅ `updateHostElement` - 단위 테스트
- ✅ `handleVNodeTextProperty` - 단위 테스트
- ✅ `handlePrimitiveTextChild` - 단위 테스트
- ✅ `handleTextOnlyVNode` - 단위 테스트
- ✅ `cloneVNodeTree` - 단위 테스트
- ✅ `getVNodeId` - 단위 테스트
- ✅ `normalizeClasses` - 단위 테스트
- ✅ `vnodeStructureMatches` - 단위 테스트
- ✅ `findChildHost` - 단위 테스트
- ✅ `removeStaleEarly` - 단위 테스트
- ✅ `handlePortalVNode` - 단위 테스트
- ✅ `transferMetaFromPrevToNext` - 단위 테스트

### 테스트되지 않았거나 부족한 함수들

#### 1. `findPrevChildVNode`
- **위치**: `packages/renderer-dom/src/reconcile/utils/host-finding.ts:236`
- **용도**: `prevChildVNodes` 배열에서 현재 `vnode`와 매칭되는 `prevChildVNode` 찾기
- **테스트 필요성**: ⚠️ 중간 - `reconcileFiberNode`에서 사용되지만 직접 테스트 없음
- **테스트 파일**: `reconcile-utils-host-finding.test.ts`에 일부 포함되어 있을 수 있음

#### 2. `updateHostTextContent`
- **위치**: `packages/renderer-dom/src/reconcile/utils/text-node-handlers.ts:264`
- **용도**: Host element의 텍스트 콘텐츠 업데이트
- **테스트 필요성**: ⚠️ 낮음 - `handleVNodeTextProperty`에서 사용되지만 직접 테스트 없음
- **테스트 파일**: `reconcile-utils-text-node-handlers.test.ts`에 포함되어 있을 수 있음

#### 3. `reorder`
- **위치**: `packages/renderer-dom/src/reconcile/utils/dom-utils.ts:95`
- **용도**: DOM children 순서 재정렬
- **테스트 필요성**: ⚠️ 중간 - 사용되는 곳이 많지만 직접 테스트 없음
- **테스트 파일**: `reconcile-utils-dom-utils.test.ts`에 포함되어 있을 수 있음

#### 4. `queryHost`
- **위치**: `packages/renderer-dom/src/reconcile/utils/dom-utils.ts:87`
- **용도**: `sid`로 host element 찾기
- **테스트 필요성**: ⚠️ 낮음 - 사용되는 곳이 많지만 직접 테스트 없음
- **테스트 파일**: `reconcile-utils-dom-utils.test.ts`에 포함되어 있을 수 있음

## 분리 가능한 로직

### 1. `reconcileFiberNode` 함수 분리 (253줄 → 여러 작은 함수)

현재 `reconcileFiberNode`는 너무 크고 여러 책임을 가지고 있습니다:

#### 분리 가능한 부분들:

**A. ID 전달 로직 (139-167줄)**
```typescript
// 분리 가능: transferVNodeIdFromPrev
function transferVNodeIdFromPrev(
  vnode: VNode,
  prevVNode: VNode | undefined
): void {
  const vnodeId = getVNodeId(vnode);
  const prevVNodeId = getVNodeId(prevVNode);
  if (!vnodeId && prevVNodeId && prevVNode) {
    if (prevVNode.stype && prevVNode.stype === vnode.stype) {
      if (prevVNode.sid) {
        vnode.sid = prevVNode.sid;
      } else if (prevVNode.decoratorSid) {
        vnode.decoratorSid = prevVNode.decoratorSid;
      }
    }
  }
}

// 분리 가능: generateVNodeIdIfNeeded
function generateVNodeIdIfNeeded(
  vnode: VNode,
  fiber: FiberNode,
  components: ComponentManager
): void {
  if (!vnode.sid && vnode.stype && components) {
    const componentManager = components as any;
    if (typeof componentManager.generateComponentId === 'function') {
      const generatedSid = componentManager.generateComponentId(vnode, fiber.index);
      if (generatedSid) {
        markAutoGeneratedSid(vnode, generatedSid);
      }
    }
  }
}
```

**B. Host 찾기 로직 (223-313줄)**
```typescript
// 분리 가능: findOrCreateHost
function findOrCreateHost(
  fiber: FiberNode,
  deps: FiberReconcileDependencies,
  context: any
): HTMLElement {
  const { dom, components } = deps;
  const vnode = fiber.vnode;
  const prevVNode = fiber.prevVNode;
  const parent = fiber.parent;
  
  // 1. prevVNode.meta.domElement 확인
  let host = findHostFromPrevVNode(vnode, prevVNode);
  
  // 2. findHostForChildVNode로 찾기
  if (!host) {
    const prevChildVNodes = prevVNode?.children || [];
    const prevChildToElement = buildPrevChildToElementMap(prevChildVNodes);
    host = findHostForChildVNode(
      parent,
      vnode,
      fiber.index,
      prevChildVNodes,
      prevChildToElement
    );
  }
  
  // 3. findHostInParentChildren로 찾기
  if (!host) {
    host = findHostInParentChildren(parent, vnode, prevVNode, fiber.index);
  }
  
  // 4. 새로 생성
  if (!host) {
    host = createHostElement(
      parent,
      vnode,
      fiber.index,
      dom,
      components as ComponentLifecycleManager,
      context
    );
  } else {
    // 기존 host 업데이트
    updateExistingHost(host, parent, vnode, prevVNode, fiber.index, prevChildVNodes, deps, context);
  }
  
  return host;
}

// 분리 가능: findHostFromPrevVNode
function findHostFromPrevVNode(
  vnode: VNode,
  prevVNode: VNode | undefined
): HTMLElement | null {
  if (prevVNode?.meta?.domElement instanceof HTMLElement) {
    const vnodeId = getVNodeId(vnode);
    const prevVNodeId = getVNodeId(prevVNode);
    
    // 같은 ID를 가진 경우 재사용
    if (vnodeId && prevVNodeId && vnodeId === prevVNodeId) {
      return prevVNode.meta.domElement;
    }
    
    // ID가 없는 경우: 구조적 매칭
    if (!vnodeId && !prevVNodeId && vnode.tag === prevVNode.tag) {
      const vnodeClasses = normalizeClasses(vnode.attrs?.class || vnode.attrs?.className).sort();
      const prevClasses = normalizeClasses(prevVNode.attrs?.class || prevVNode.attrs?.className).sort();
      if (vnodeClasses.length === prevClasses.length && 
          vnodeClasses.every((cls, i) => cls === prevClasses[i])) {
        return prevVNode.meta.domElement;
      }
    }
  }
  return null;
}

// 분리 가능: buildPrevChildToElementMap
function buildPrevChildToElementMap(
  prevChildVNodes: (VNode | string | number)[]
): Map<VNode | string | number, HTMLElement | Text> {
  const prevChildToElement = new Map<VNode | string | number, HTMLElement | Text>();
  for (const prevChild of prevChildVNodes) {
    if (typeof prevChild === 'object' && prevChild?.meta?.domElement) {
      prevChildToElement.set(prevChild, prevChild.meta.domElement);
    }
  }
  return prevChildToElement;
}

// 분리 가능: updateExistingHost
function updateExistingHost(
  host: HTMLElement,
  parent: HTMLElement,
  vnode: VNode,
  prevVNode: VNode | undefined,
  index: number,
  prevChildVNodes: (VNode | string | number)[],
  deps: FiberReconcileDependencies,
  context: any
): void {
  const { dom, components } = deps;
  let prevChildVNode = findPrevChildVNode(vnode, index, prevChildVNodes);
  if (!prevChildVNode && prevVNode && prevVNode.sid === vnode.sid) {
    prevChildVNode = prevVNode;
  }
  updateHostElement(
    host,
    parent,
    vnode,
    index,
    prevChildVNode,
    prevChildVNodes,
    dom,
    components as ComponentLifecycleManager,
    context
  );
}
```

**C. 자식 Fiber parent 업데이트 (322-330줄)**
```typescript
// 분리 가능: updateChildFiberParents
function updateChildFiberParents(fiber: FiberNode, host: HTMLElement): void {
  let childFiber = fiber.child;
  while (childFiber) {
    childFiber.parent = host;
    childFiber = childFiber.sibling;
  }
}
```

**D. prevVNodeTree 저장 (372-379줄)**
```typescript
// 분리 가능: saveVNodeToTree
function saveVNodeToTree(
  vnode: VNode,
  prevVNodeTree: Map<string, VNode> | undefined
): void {
  if (prevVNodeTree && vnode.sid) {
    try {
      prevVNodeTree.set(String(vnode.sid), cloneVNodeTree(vnode));
    } catch (error) {
      // Silent fail
    }
  }
}
```

### 2. `removeStaleChildren` 함수 분리 (145줄 → 여러 작은 함수)

#### 분리 가능한 부분들:

**A. Expected child IDs 수집 (401-418줄)**
```typescript
// 분리 가능: collectExpectedChildIds
function collectExpectedChildIds(
  vnode: VNode
): { expectedChildIds: Set<string>; vnodeChildrenWithoutId: VNode[] } {
  const expectedChildIds = new Set<string>();
  const vnodeChildrenWithoutId: VNode[] = [];
  
  if (vnode.children) {
    for (const child of vnode.children) {
      if (typeof child === 'object' && child !== null) {
        const childVNode = child as VNode;
        const childId = getVNodeId(childVNode);
        if (childId) {
          expectedChildIds.add(childId);
        } else {
          vnodeChildrenWithoutId.push(childVNode);
        }
      }
    }
  }
  
  return { expectedChildIds, vnodeChildrenWithoutId };
}
```

**B. DOM children과 VNode children 매칭 (434-486줄)**
```typescript
// 분리 가능: matchDomChildrenWithVNodeChildren
function matchDomChildrenWithVNodeChildren(
  vnode: VNode,
  childElements: HTMLElement[],
  expectedChildIds: Set<string>,
  vnodeChildrenWithoutId: VNode[]
): Set<HTMLElement> {
  const matchedDomElements = new Set<HTMLElement>();
  
  // 1. ID 기반 매칭
  if (vnode.children) {
    for (let i = 0; i < vnode.children.length; i++) {
      const child = vnode.children[i];
      if (typeof child === 'object' && child !== null) {
        const childVNode = child as VNode;
        const childId = getVNodeId(childVNode);
        if (childId) {
          const matchedEl = childElements.find(
            el => !matchedDomElements.has(el) && (
              el.getAttribute('data-bc-sid') === childId || 
              el.getAttribute('data-decorator-sid') === childId
            )
          );
          if (matchedEl) {
            matchedDomElements.add(matchedEl);
          }
        }
      }
    }
  }
  
  // 2. 인덱스 기반 매칭 (ID가 없는 경우)
  const unmatchedDomElements = childElements.filter(el => !matchedDomElements.has(el));
  const unmatchedVNodeChildren = vnodeChildrenWithoutId.filter(
    (vnodeChild, idx) => {
      let vnodeChildIndex = -1;
      if (vnode.children) {
        for (let i = 0; i < vnode.children.length; i++) {
          const child = vnode.children[i];
          if (typeof child === 'object' && child !== null && child === vnodeChild) {
            vnodeChildIndex = i;
            break;
          }
        }
      }
      return vnodeChildIndex >= 0;
    }
  );
  
  for (let i = 0; i < Math.min(unmatchedVNodeChildren.length, unmatchedDomElements.length); i++) {
    const vnodeChild = unmatchedVNodeChildren[i];
    const domEl = unmatchedDomElements[i];
    if (vnodeChild.tag && domEl.tagName.toLowerCase() === vnodeChild.tag.toLowerCase()) {
      matchedDomElements.add(domEl);
    }
  }
  
  return matchedDomElements;
}
```

**C. 사용되지 않은 요소 제거 (488-533줄)**
```typescript
// 분리 가능: removeUnmatchedChildren
function removeUnmatchedChildren(
  host: HTMLElement,
  childElements: HTMLElement[],
  matchedDomElements: Set<HTMLElement>,
  expectedChildIds: Set<string>,
  prevChildVNodes: (VNode | string | number)[],
  components: ComponentManager,
  context: any
): void {
  for (const childEl of childElements) {
    if (matchedDomElements.has(childEl)) {
      continue;
    }
    
    const sid = childEl.getAttribute('data-bc-sid');
    const decoratorSid = childEl.getAttribute('data-decorator-sid');
    const childId = decoratorSid || sid;
    
    if (childId) {
      if (!expectedChildIds.has(childId)) {
        const prevChildVNode = prevChildVNodes.find(
          (c): c is VNode => {
            if (typeof c !== 'object' || c === null) return false;
            const prevId = getVNodeId(c);
            return prevId === childId;
          }
        );
        
        if (prevChildVNode && prevChildVNode.stype && prevChildVNode.sid) {
          try {
            components.unmountComponent(prevChildVNode, context);
          } catch (err) {
            console.error('[Fiber.removeStaleChildren] Error unmounting component:', err);
          }
        }
        
        try {
          host.removeChild(childEl);
        } catch {
          // 이미 제거되었을 수 있음
        }
      }
    } else {
      try {
        host.removeChild(childEl);
      } catch {
        // 이미 제거되었을 수 있음
      }
    }
  }
}
```

## 권장 사항

### 우선순위 1: 테스트 추가
1. **`findPrevChildVNode` 테스트** - `reconcileFiberNode`에서 중요한 역할
2. **`reorder` 테스트** - DOM 순서 재정렬 로직 검증
3. **`queryHost` 테스트** - sid 기반 host 찾기 검증

### 우선순위 2: 함수 분리
1. **`reconcileFiberNode` 분리** - 가장 큰 함수, 여러 책임
   - ID 전달 로직 분리
   - Host 찾기 로직 분리
   - 자식 Fiber parent 업데이트 분리
2. **`removeStaleChildren` 분리** - 복잡한 매칭 로직
   - Expected child IDs 수집 분리
   - DOM-VNode 매칭 분리
   - 제거 로직 분리

### 우선순위 3: 엣지 케이스 테스트
1. **깊게 중첩된 구조** - 여러 레벨의 중첩
2. **동일한 ID를 가진 여러 요소** - 다른 부모 아래
3. **빠른 연속 업데이트** - 여러 번의 render 호출
4. **Portal과 일반 요소 혼합** - Portal 내부와 외부 요소

## 테스트 파일 구조 제안

```
test/core/
  fiber/
    fiber-reconciler-id-transfer.test.ts      # ID 전달 로직
    fiber-reconciler-host-finding.test.ts     # Host 찾기 로직
    fiber-reconciler-child-update.test.ts     # 자식 Fiber 업데이트
    fiber-remove-stale-matching.test.ts       # 매칭 로직
    fiber-remove-stale-removal.test.ts        # 제거 로직
  reconcile-utils/
    find-prev-child-vnode.test.ts             # findPrevChildVNode
    reorder.test.ts                           # reorder
    query-host.test.ts                         # queryHost
```

