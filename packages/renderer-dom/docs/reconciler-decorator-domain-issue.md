# Reconciler의 Decorator 도메인 개념 사용 문제 분석

## 핵심 문제

**Reconciler는 decorator라는 도메인 개념을 모르고 있어야 합니다.**
- Reconciler는 단지 VNode를 처리할 뿐입니다.
- VNode의 속성 이름에 "decorator"라는 도메인 이름이 포함되어 있어도, reconciler는 그것을 특별히 인식하지 않아야 합니다.

## 현재 문제점

### 1. Decorator 속성 직접 접근

Reconciler 코드에서 `decoratorSid`, `decoratorStype`, `decoratorCategory`, `decoratorPosition` 같은 **"decorator"라는 이름이 붙은 속성**을 직접 접근하고 있습니다.

#### 문제가 있는 파일들:

1. **`host-management.ts`** (가장 심각)
   - `childVNode.decoratorSid` 직접 접근 (line 107, 262)
   - `childVNode.decoratorStype` 직접 접근 (line 110, 265)
   - `childVNode.decoratorCategory` 직접 접근 (line 113, 268)
   - `childVNode.decoratorPosition` 직접 접근 (line 116, 271)
   - DOM 속성으로 변환: `data-decorator-sid`, `data-decorator-stype` 등

2. **`fiber-reconciler-helpers.ts`**
   - `prevVNode.decoratorSid` 직접 접근 (line 38-39)

3. **`fiber-reconciler.ts`**
   - `data-decorator-sid` DOM 속성 직접 접근 (line 314)

4. **`fiber-tree.ts`**
   - `prevChildVNode.decoratorSid` 직접 접근 (line 142-143)

5. **`meta-utils.ts`**
   - `prevChildVNode.sid || prevChildVNode.decoratorSid` 직접 접근 (line 45-46)

6. **`reconciler.ts`**
   - `v.sid || v.decoratorSid` 직접 접근 (line 241)

### 2. 주석과 실제 코드의 불일치

주석에는 "decorator 구분 없음", "Domain 지식 없이"라고 되어 있지만, 실제 코드는 `decoratorSid` 같은 도메인 특정 속성을 직접 접근하고 있습니다.

예시:
```typescript
// 주석: "VNode만 처리, decorator 구분 없음"
// 실제 코드: childVNode.decoratorSid 직접 접근
if (childVNode.decoratorSid) {
  dom.setAttribute(host, 'data-decorator-sid', String(childVNode.decoratorSid));
}
```

## 올바른 접근 방식

### 원칙

1. **Reconciler는 VNode의 구조적 속성만 처리**
   - `sid`, `stype`, `tag`, `attrs`, `children` 등 구조적 속성
   - 도메인 특정 이름(`decorator*`)을 직접 인식하지 않음

2. **식별자는 일반화된 방식으로 처리**
   - `getVNodeId()`는 이미 올바르게 구현됨: `vnode.sid || vnode.decoratorSid`
   - 하지만 이 함수 내부에서도 `decoratorSid`를 직접 접근하는 것은 문제

3. **DOM 속성 변환도 일반화**
   - VNode의 모든 식별자/메타데이터 속성을 일반화된 방식으로 DOM 속성으로 변환
   - `data-decorator-*` 같은 특정 도메인 이름을 하드코딩하지 않음

## 해결 방안

### 1. VNode 식별자 추상화

VNode의 모든 식별자 속성을 일반화된 방식으로 처리:

```typescript
// 현재 (문제)
if (childVNode.decoratorSid) {
  dom.setAttribute(host, 'data-decorator-sid', String(childVNode.decoratorSid));
}

// 올바른 방식 (제안)
// VNode의 모든 식별자 속성을 동적으로 처리
const vnodeId = getVNodeId(childVNode);
if (vnodeId && vnodeId !== childVNode.sid) {
  // decoratorSid인 경우를 일반화된 방식으로 처리
  // 하지만 여전히 "decorator"라는 이름을 사용하는 것은 문제
}
```

### 2. VNode 메타데이터 속성 일반화

VNode의 모든 메타데이터 속성을 일반화된 방식으로 처리:

```typescript
// 현재 (문제)
if (childVNode.decoratorStype) {
  dom.setAttribute(host, 'data-decorator-stype', String(childVNode.decoratorStype));
}
if (childVNode.decoratorCategory) {
  dom.setAttribute(host, 'data-decorator-category', String(childVNode.decoratorCategory));
}

// 올바른 방식 (제안)
// VNode의 모든 메타데이터 속성을 동적으로 처리
// 하지만 VNode 타입 정의 자체가 decorator* 속성을 가지고 있으므로,
// 이것은 VNode 타입 정의의 문제일 수도 있음
```

### 3. 근본적인 해결책

**VNode 타입 정의를 변경하여 decorator 속성을 일반화된 속성으로 변경:**

```typescript
// 현재 VNode 타입
interface VNode {
  sid?: string;
  decoratorSid?: string;  // 문제: 도메인 특정 이름
  decoratorStype?: string;  // 문제: 도메인 특정 이름
  // ...
}

// 제안: 일반화된 속성
interface VNode {
  sid?: string;
  // decorator 속성을 일반화된 메타데이터로 변경
  metadata?: {
    [key: string]: any;  // decoratorSid, decoratorStype 등을 포함
  };
  // 또는
  alternateId?: string;  // decoratorSid 대신
  alternateType?: string;  // decoratorStype 대신
}
```

하지만 이것은 VNode 타입 정의의 큰 변경이므로, 더 현실적인 접근은:

### 4. 실용적인 해결책

**Reconciler 레벨에서 decorator 속성을 일반화된 방식으로 처리:**

1. **식별자 처리**: `getVNodeId()` 사용 (이미 올바름)
2. **메타데이터 속성 처리**: VNode의 모든 속성을 순회하여 DOM 속성으로 변환
3. **도메인 특정 이름 제거**: `decorator*` 같은 이름을 직접 사용하지 않고, 동적으로 처리

```typescript
// 제안: VNode의 모든 속성을 동적으로 처리
function setVNodeAttributesToDOM(
  host: HTMLElement,
  vnode: VNode,
  dom: DOMOperations
): void {
  // sid 처리
  if (vnode.sid && !isAutoGeneratedSid(vnode)) {
    dom.setAttribute(host, 'data-bc-sid', String(vnode.sid));
  }
  
  // 모든 메타데이터 속성을 동적으로 처리
  // decorator* 속성도 여기서 일반화된 방식으로 처리
  // 하지만 여전히 VNode 타입에 decorator* 속성이 있으므로,
  // 이것은 완전한 해결책은 아님
}
```

## 해결 완료 ✅

### 적용된 해결책

**VNodeBuilder에서 decorator 정보를 `attrs`에 저장하도록 변경:**

1. **DecoratorProcessor 수정**
   - `decoratorSid`, `decoratorStype`, `decoratorCategory`, `decoratorPosition`을 top-level이 아닌 `attrs['data-decorator-*']`에 저장
   - Reconciler는 `attrs`를 그대로 DOM에 복사하므로, decorator 도메인 개념을 알 필요 없음

2. **getVNodeId() 수정**
   - `vnode.sid || vnode.attrs?.['data-decorator-sid']`로 변경
   - attrs에서도 읽을 수 있도록 수정

3. **Reconciler 수정**
   - 모든 `decorator*` 속성 직접 접근 제거
   - `attrs`를 그대로 DOM에 복사 (processChildVNode에서 자동 처리)
   - `getVNodeId()` 사용으로 통일

### 수정된 파일들

1. ✅ `packages/renderer-dom/src/vnode/decorator/processor.ts`
   - 모든 `decoratorSid` 등을 `attrs['data-decorator-sid']`로 변경

2. ✅ `packages/renderer-dom/src/reconcile/utils/vnode-utils.ts`
   - `getVNodeId()`가 attrs에서도 읽도록 수정

3. ✅ `packages/renderer-dom/src/reconcile/utils/host-management.ts`
   - decorator 속성 직접 접근 제거
   - attrs를 그대로 복사하도록 변경

4. ✅ `packages/renderer-dom/src/reconcile/fiber/fiber-reconciler-helpers.ts`
   - `transferVNodeIdFromPrev()`에서 attrs 사용

5. ✅ `packages/renderer-dom/src/reconcile/fiber/fiber-tree.ts`
   - attrs 사용으로 변경

6. ✅ `packages/renderer-dom/src/reconcile/reconciler.ts`
   - attrs 사용으로 변경

7. ✅ `packages/renderer-dom/src/reconcile/utils/meta-utils.ts`
   - `getVNodeId()` 사용으로 통일

### 결과

- ✅ Reconciler는 decorator 도메인 개념을 모름
- ✅ Reconciler는 단지 VNode의 `attrs`를 DOM에 복사할 뿐
- ✅ VNodeBuilder가 도메인 지식을 가지고 `attrs`에 적절한 속성을 설정
- ✅ 모든 decorator* 속성 직접 접근 제거 완료

