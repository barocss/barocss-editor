# 역변환 기반 편집 알고리즘 개념 검토

## 현재 접근 방식 요약

우리는 **DOM → Model 역변환** 방식으로 contenteditable 편집을 처리합니다:

```
사용자 편집 (DOM)
  ↓
MutationObserver 감지
  ↓
DOM에서 텍스트 재구성 (reconstructModelTextFromRuns)
  ↓
편집 위치 파악 (convertDOMToModelPosition)
  ↓
Mark/Decorator 범위 조정 (adjustMarkRanges, adjustDecoratorRanges)
  ↓
Model 업데이트 (text_replace 트랜잭션)
  ↓
렌더러가 DOM 재렌더링
```

## 이 방식이 적합한 이유

### ✅ 장점

1. **contenteditable과의 자연스러운 통합**
   - 브라우저의 네이티브 편집 기능을 그대로 활용
   - 복사/붙여넣기, 드래그 앤 드롭 등이 자동으로 작동
   - IME 입력, 자동완성 등 브라우저 기능 활용 가능

2. **단일 소스 오브 트루스 (Single Source of Truth)**
   - DOM이 실제 편집이 발생하는 곳
   - DOM을 기준으로 하면 동기화 문제가 적음
   - Model은 DOM의 "역변환" 결과로 항상 최신 상태 보장

3. **명시적 제어**
   - `adjustMarkRanges`, `adjustDecoratorRanges`로 명시적으로 범위 조정
   - 로직이 명확하고 디버깅이 쉬움
   - 커스터마이징이 자유로움

4. **유연성**
   - 다양한 DOM 구조에 대응 가능
   - Mark와 Decorator의 복잡한 중첩 처리 가능

### ⚠️ 잠재적 문제점과 해결 방안

#### 1. **편집 위치 추정의 부정확성**

**문제:**
- 공통 접두사 방식은 복잡한 편집에서 부정확할 수 있음
- 예: `"abc"` → `"xyz"` (완전 교체)의 경우 editPosition = 0이지만 실제로는 전체 교체

**현재 해결:**
- Selection API로 편집 위치를 먼저 시도
- 실패 시 공통 접두사로 fallback
- 대부분의 경우 잘 작동함

**개선 방안:**
- LCS (Longest Common Subsequence) 알고리즘 사용
- `@barocss/text-analyzer`의 `analyzeTextChanges` 활용 가능
- 우선순위: 중간 (현재도 충분히 작동)

#### 2. **여러 text node 동시 변경**

**문제:**
- MutationObserver는 개별 text node의 변경만 감지
- 여러 text node가 동시에 변경되면 여러 번 호출됨

**현재 해결:**
- 매번 전체 텍스트를 재구성하여 최종 상태 보장
- `handleEfficientEdit`가 한 번만 호출되도록 보장

**개선 방안:**
- 배치 처리: 짧은 시간 내 여러 변경을 모아서 한 번에 처리
- 우선순위: 낮음 (현재 방식도 충분히 작동)

#### 3. **성능 이슈**

**문제:**
- 매번 Text Run Index를 구축 (O(n) where n = text nodes)
- 전체 텍스트 재구성

**현재 해결:**
- inline-text 노드 내 text node 개수가 보통 적음 (10개 이하)
- 성능 영향이 미미함
- 캐싱 제거로 정확성 향상

**개선 방안:**
- beforeinput 이벤트로 편집 위치 미리 파악 (캐싱)
- 우선순위: 중간 (성능 향상)

#### 4. **유니코드 처리**

**문제:**
- 이모지, 결합 문자 등 복합 문자의 경우 범위 조정이 정확하지 않을 수 있음
- UTF-16 서로게이트 페어 처리 필요

**현재 해결:**
- JavaScript 문자열은 UTF-16 기반이므로 대부분의 경우 자동 처리
- 일반적인 사용에서는 문제 없음

**개선 방안:**
- `Array.from(text)`로 유니코드 문자 단위 계산
- 우선순위: 낮음 (대부분의 경우 현재 방식으로 충분)

#### 5. **DOM과 Model의 불일치 가능성**

**문제:**
- DOM이 변경되었지만 Model 업데이트가 실패한 경우
- Model과 DOM이 불일치할 수 있음

**현재 해결:**
- 렌더러가 항상 Model을 기준으로 DOM을 재렌더링
- Model 업데이트 후 자동으로 DOM 동기화

**개선 방안:**
- 주기적인 동기화 검증 (선택적)
- 우선순위: 낮음 (렌더러가 자동 처리)

## 다른 접근 방식과의 비교

### Model → DOM (단방향) 방식

**예시:** ProseMirror, Slate, Draft.js

```
사용자 편집 (Model)
  ↓
Transaction/Operation 생성
  ↓
Model 업데이트
  ↓
DOM 재렌더링
```

**장점:**
- Model이 항상 정확
- 편집 위치가 명확
- 범위 조정이 자동

**단점:**
- contenteditable의 네이티브 기능 활용 어려움
- 복사/붙여넣기, 드래그 앤 드롭 등 수동 구현 필요
- IME 입력 처리 복잡

### DOM → Model (역변환) 방식 (우리 방식)

**장점:**
- contenteditable과 자연스러운 통합
- 브라우저 기능 활용 가능
- 유연성

**단점:**
- 역변환 로직 필요
- 편집 위치 추정의 부정확성 가능
- 범위 조정을 수동으로 처리

## 결론: 이 방식이 적합한가?

### ✅ **적합한 경우:**

1. **contenteditable 기반 에디터**
   - 브라우저의 네이티브 편집 기능을 최대한 활용하고 싶을 때
   - 복사/붙여넣기, 드래그 앤 드롭 등이 자동으로 작동해야 할 때

2. **복잡한 Mark/Decorator 구조**
   - 여러 레벨의 중첩이 필요할 때
   - 동적으로 구조가 변경될 때

3. **명시적 제어가 필요한 경우**
   - 범위 조정 로직을 커스터마이징하고 싶을 때
   - 디버깅이 쉬운 구조가 필요할 때

### ⚠️ **주의가 필요한 경우:**

1. **대용량 텍스트**
   - 매우 긴 텍스트의 경우 성능 이슈 가능
   - 해결: 가상화 (virtualization) 또는 청크 단위 처리

2. **복잡한 편집 시나리오**
   - 여러 노드에 걸친 편집
   - 해결: 배치 처리 또는 트랜잭션 그룹화

3. **실시간 협업**
   - 여러 사용자가 동시에 편집하는 경우
   - 해결: Operational Transform (OT) 또는 CRDT 통합

## 개선 권장 사항

### 즉시 개선 (높은 우선순위)

1. ✅ **범위 조정 로직의 엣지 케이스 처리** (완료)
   - 삭제가 mark 범위를 완전히 지우는 경우
   - 편집 위치가 범위 경계에 있는 경우

2. ✅ **에러 처리 강화** (완료)
   - textNode가 DOM에서 제거된 경우
   - runs가 비어있는 경우
   - editPosition 유효성 검사

### 점진적 개선 (중간 우선순위)

3. **편집 위치 추정의 정확성 개선**
   - LCS/Diff 알고리즘 사용
   - `analyzeTextChanges` 활용

4. **beforeinput 이벤트 활용**
   - 편집 위치 미리 파악
   - 성능 향상

### 선택적 개선 (낮은 우선순위)

5. **여러 text node 동시 변경 처리**
   - 배치 처리
   - 현재 방식도 충분히 작동

6. **유니코드 처리 개선**
   - 복합 문자 처리
   - 대부분의 경우 현재 방식으로 충분

## 최종 평가

### ✅ **이 방식으로 진행해도 됩니다**

**이유:**
1. **contenteditable 기반 에디터에 적합**: 브라우저의 네이티브 기능을 최대한 활용
2. **명시적 제어**: 로직이 명확하고 디버깅이 쉬움
3. **유연성**: 다양한 DOM 구조와 Mark/Decorator 중첩 처리 가능
4. **안정성**: 주요 엣지 케이스 처리 완료, 에러 처리 강화

**주의사항:**
- 편집 위치 추정의 정확성은 대부분의 경우 충분하지만, 복잡한 편집에서는 개선 여지가 있음
- 성능은 현재 충분하지만, 대용량 텍스트에서는 최적화 필요할 수 있음

**결론:**
현재 접근 방식은 contenteditable 기반 에디터에 적합하며, 주요 개선 사항을 적용했으므로 안정적으로 사용할 수 있습니다. 추가 개선은 실제 사용 중 발견되는 문제에 따라 점진적으로 진행하면 됩니다.

